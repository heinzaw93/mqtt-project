[
    {
        "id": "dbfebf7401afce77",
        "type": "tab",
        "label": "Registration",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "8efd17ed78926cf4",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "openssl ecparam -genkey -name prime256v1 -out /etc/mosquitto/certs/alice-private-key.pem",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create Alice Private Key ",
        "x": 450,
        "y": 260,
        "wires": [
            [
                "8a43c52da89922e6"
            ],
            [],
            []
        ]
    },
    {
        "id": "8a43c52da89922e6",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "openssl ec -in /etc/mosquitto/certs/alice-private-key.pem -pubout -out /etc/mosquitto/certs/alice-public-key.pem",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create Alice Public Key ",
        "x": 710,
        "y": 260,
        "wires": [
            [
                "9e03d0b684252a69"
            ],
            [],
            []
        ]
    },
    {
        "id": "b6378d683b9231cc",
        "type": "mqtt out",
        "z": "dbfebf7401afce77",
        "name": "Publish Alice Public Key",
        "topic": "keys/public key/alice",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "873502a2020d1559",
        "x": 1230,
        "y": 240,
        "wires": []
    },
    {
        "id": "59b5c464f3c53a42",
        "type": "mqtt in",
        "z": "dbfebf7401afce77",
        "name": "Subscribe Sunny Public Key",
        "topic": "keys/registration/alice",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "873502a2020d1559",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 160,
        "y": 400,
        "wires": [
            [
                "142889e16226db05"
            ]
        ]
    },
    {
        "id": "c6d35c8c7661e0a2",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Prepare Data for Registration",
        "func": "  const fs = global.get('fs');\nconst crypto = global.get('crypto');\nconst os = global.get('os');\n\ntry {\n    const device_name = \"alice\";  // ‚úÖ Set device name\n    flow.set('device_name', device_name);  // ‚úÖ Store in flow context\n\n    // ‚úÖ Step 1: Get MAC Addresses from wireless interfaces only\n    const networkInterfaces = os.networkInterfaces();\n    let macAddresses = [];\n\n    for (let iface in networkInterfaces) {\n        if (iface.startsWith('wlan') || iface.startsWith('wlx')) {\n            networkInterfaces[iface].forEach((detail) => {\n                if (detail.mac && !macAddresses.includes(detail.mac)) {\n                    macAddresses.push(detail.mac);\n                    node.log(`üü¢ MAC Address Found on ${iface}: ${detail.mac}`);\n                }    \n            });\n        }\n    }\n\n    const macAddress1 = macAddresses[0] || \"00:00:00:00:00:00\";\n    const macAddress2 = macAddresses[1] || \"00:00:00:00:00:00\";\n\n    flow.set('macAddress1', macAddress1);\n    flow.set('macAddress2', macAddress2);\n\n\n    // ‚úÖ Step 3: Prepare Data for Signing\n    const dataToSign = `${macAddresses.join(',')}|${device_name}`;\n\n    // ‚úÖ Step 4: Sign the Data using ECDSA\n    const privateKeyPath = '/etc/mosquitto/certs/alice-private-key.pem';\n    const privateKeyPEM = fs.readFileSync(privateKeyPath, 'utf8');\n    const signer = crypto.createSign('sha256');\n    signer.update(dataToSign);\n    signer.end();\n    const signature = signer.sign(privateKeyPEM, 'base64');\n\n    // ‚úÖ Step 5: Generate AES Key from existing secret key file\n    const secretKeyPath = '/etc/mosquitto/certs/alice-registration-secret-key.bin';\n    const secretKeyBin = fs.readFileSync(secretKeyPath);  // Direct binary read\n    const aesKey = crypto.createHash('sha256').update(secretKeyBin).digest();\n\n    // ‚úÖ Step 6: Encrypt sensitive payload\n    const iv = crypto.randomBytes(16);\n    const cipher = crypto.createCipheriv('aes-256-cbc', aesKey, iv);\n\n    const sensitivePayload = JSON.stringify({\n        device_name,\n        macAddresses,\n    });\n\n    let encrypted = cipher.update(sensitivePayload, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n\n    // ‚úÖ Step 7: Final MQTT Payload\n    msg.payload = {\n        encryptedData: encrypted,\n        iv: iv.toString('hex'),\n        sign: signature\n    };\n\n    // ‚úÖ Logging\n    //node.warn(`Data to Sign: ${dataToSign}`);\n    //node.warn(`Signature: ${signature}`);\n    //node.warn(`Encrypted Data Length: ${encrypted.length}`);\n\n\n    return msg;\n} catch (err) {\n    node.error(`Error: ${err.message}`);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1100,
        "y": 420,
        "wires": [
            [
                "482c0eebd84f0dc6"
            ]
        ]
    },
    {
        "id": "482c0eebd84f0dc6",
        "type": "mqtt out",
        "z": "dbfebf7401afce77",
        "name": "Publish Registration Request",
        "topic": "registration/request/alice",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "873502a2020d1559",
        "x": 1360,
        "y": 380,
        "wires": []
    },
    {
        "id": "3660bd62b5a422bb",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Decrypt the Registration respond",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// --- File paths ---\nconst MQTTScertFilePath = \"/etc/mosquitto/certs/MQTTS.pem\";\nconst prov_pass_path = \"/etc/mosquitto/certs/provisioner_password\";\nconst secretKeyPath = \"/etc/mosquitto/certs/alice-registration-secret-key.bin\";\n\n// --- Read Jonny's AES-256 secret key (binary) ---\nconst secretKEYPEM = fs.readFileSync(secretKeyPath);\n\n// --- Extract encrypted payload from MQTT ---\nconst { encryptedData, iv, sign } = msg.payload;\n\n// --- Derive AES key from secret ---\nconst aesKey = crypto.createHash('sha256').update(secretKEYPEM).digest();\n\n// --- Decrypt AES-256-CBC payload ---\nconst decipher = crypto.createDecipheriv('aes-256-cbc', aesKey, Buffer.from(iv, 'hex'));\nlet decrypted = decipher.update(encryptedData, 'hex', 'utf8');\ndecrypted += decipher.final('utf8');\n\n// --- Parse JSON content from decrypted payload ---\nconst decryptedData = JSON.parse(decrypted);\n\n// --- Extract Sunny's public key from payload ---\nconst sunnyPublicKey = decryptedData.sunnyPublicKey;\n\n// --- Recreate signed content for verification ---\nconst dataToVerify = `${decryptedData.deviceID}|${decryptedData.MQTTS_CA_Certificate}|${decryptedData.fingerprint}|${decryptedData.ca_url}|${decryptedData.prov_pass}|${decryptedData.jwt}|${decryptedData.registered_at}|${sunnyPublicKey}|${decryptedData.is_broker}`;\n\n// --- ECDSA Signature Verification ---\nconst verifier = crypto.createVerify('sha256');\nverifier.update(dataToVerify);\nverifier.end();\n\nconst isVerified = verifier.verify(sunnyPublicKey, sign, 'base64');\nif (!isVerified) {\n    node.error(\"‚ùå Signature verification failed! Possible data tampering.\");\n    return null;\n}\n\n// --- Retrieve MAC addresses and device name from flow context ---\nconst macAddress1 = flow.get('macAddress1') || \"00:00:00:00:00:00\";\nconst macAddress2 = flow.get('macAddress2') || \"00:00:00:00:00:00\";\nconst deviceName = flow.get('device_name') || \"unknown\";\n\n// --- Store only device ID, CA finger print and URl in global context (optional) ---\nglobal.set('deviceID', decryptedData.deviceID, 'file');\nglobal.set('fingerprint', decryptedData.fingerprint, 'file');\nglobal.set('ca_url', decryptedData.ca_url, 'file');\n// --- Save received certs to disk ---\nfs.writeFileSync(MQTTScertFilePath, decryptedData.MQTTS_CA_Certificate, 'utf8');\nfs.writeFileSync(\"/etc/mosquitto/certs/sunny-public-key.pem\", sunnyPublicKey, 'utf8');\nfs.writeFileSync(prov_pass_path, decryptedData.prov_pass, 'utf8');\n// --- SQLCipher: Insert into DeviceProfile ---\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// Escape single quotes in JWT for safe SQL\nconst escapedJwt = decryptedData.jwt.replace(/'/g, \"''\");\n\n// --- Construct SQL INSERT ---\nconst sqlInsert = `\nPRAGMA key = '${pragmaKey}';\nINSERT OR REPLACE INTO DeviceProfile (\n    device_id, device_name, mac_address_1, mac_address_2, jwt_token, is_broker, authentication_status, registered_at\n)\nVALUES (\n    '${decryptedData.deviceID}', '${deviceName}', '${macAddress1}', '${macAddress2}', '${escapedJwt}', ${decryptedData.is_broker}, NULL, ${decryptedData.registered_at}\n);\n`;\n\n// --- Output for exec node ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlInsert.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 620,
        "wires": [
            [
                "217a91a4307d453a"
            ]
        ]
    },
    {
        "id": "b64eee3ac18933f3",
        "type": "comment",
        "z": "dbfebf7401afce77",
        "name": "Create Alice public/private key and publish public key to Sunny",
        "info": "",
        "x": 240,
        "y": 180,
        "wires": []
    },
    {
        "id": "1d335731ce2a1c8e",
        "type": "comment",
        "z": "dbfebf7401afce77",
        "name": "Create registration secret key and publish registration request payload to central broker",
        "info": "\n\n\n",
        "x": 320,
        "y": 340,
        "wires": []
    },
    {
        "id": "2453335bce693e1f",
        "type": "comment",
        "z": "dbfebf7401afce77",
        "name": "Subscribe registration respond to insert device profile and keys table data into database",
        "info": "",
        "x": 320,
        "y": 480,
        "wires": []
    },
    {
        "id": "217a91a4307d453a",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Insert  Data Into Device Profile Data",
        "x": 660,
        "y": 540,
        "wires": [
            [
                "63ce1f0ad32e1f89"
            ],
            [],
            []
        ]
    },
    {
        "id": "d016a9d8344a41ef",
        "type": "mqtt in",
        "z": "dbfebf7401afce77",
        "name": "Subscribe Registration Respond",
        "topic": "registration/respond/alice",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "873502a2020d1559",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 170,
        "y": 560,
        "wires": [
            [
                "3660bd62b5a422bb"
            ]
        ]
    },
    {
        "id": "9e03d0b684252a69",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Set Keys In global context",
        "func": "const fs = global.get('fs');\n\n// --- Key paths ---\nconst publicKeyPath = \"/etc/mosquitto/certs/alice-public-key.pem\";\nconst privateKeyPath = \"/etc/mosquitto/certs/alice-private-key.pem\";\n\n// --- Step 1: Read keys ---\nconst publicKey = fs.readFileSync(publicKeyPath, 'utf8').trim();\nconst privateKey = fs.readFileSync(privateKeyPath, 'utf8').trim();\n\n// --- Step 2: Store in global context ---\nglobal.set(\"public_key\", publicKey, \"file\");\nglobal.set(\"private_key\", privateKey, \"file\");\n\n// --- Step 3: Prepare payload for MQTT transmission ---\nmsg.payload = publicKey;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 200,
        "wires": [
            [
                "b6378d683b9231cc"
            ]
        ]
    },
    {
        "id": "63ce1f0ad32e1f89",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Prepare data for Keys Table",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: Define paths ---\nconst secretKeyPath = \"/etc/mosquitto/certs/alice-registration-secret-key.bin\";\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 2: Initialize key data ---\nlet deviceID;\nlet privateKey;\nlet publicKey;\nlet attempts = 0;\n\n// --- Step 3: Retry fetching global context (file scope) ---\nwhile ((!deviceID || !privateKey || !publicKey) && attempts < 5) {\n    if (!deviceID) deviceID = global.get(\"deviceID\", \"file\");\n    if (!privateKey) privateKey = global.get(\"private_key\", \"file\");\n    if (!publicKey) publicKey = global.get(\"public_key\", \"file\");\n\n    if (!deviceID || !privateKey || !publicKey) {\n        node.warn(\"Retrying retrieval of key data from global context...\");\n        attempts++;\n        const waitUntil = Date.now() + 200;\n        while (Date.now() < waitUntil); // busy-wait\n    }\n}\n\n// --- Step 4: Handle missing data ---\nif (!deviceID || !publicKey || !privateKey) {\n    node.error(\"‚ùå deviceID, publicKey, or privateKey not found in global context!\");\n    return null;\n}\n\n// --- Step 5: Read and hex-encode registration key (raw binary ‚Üí BLOB) ---\nlet secretKeyBuffer;\ntry {\n    secretKeyBuffer = fs.readFileSync(secretKeyPath); // Raw binary\n} catch (err) {\n    node.error(\"‚ùå Failed to read registration secret key: \" + err.message);\n    return null;\n}\nconst secretKeyHex = secretKeyBuffer.toString('hex'); // Convert to hex string\n\n// --- Step 6: Prepare SQL INSERT for Keys table ---\nconst sqlInsert = `\nPRAGMA key = '${pragmaKey}';\nINSERT OR REPLACE INTO Keys (device_id, private_key, public_key, registration_key)\nVALUES ('${deviceID}', '${privateKey}', '${publicKey}', X'${secretKeyHex}');\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlInsert.trim()}\"`;\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 960,
        "y": 560,
        "wires": [
            [
                "305c789f2f5495f8"
            ]
        ]
    },
    {
        "id": "305c789f2f5495f8",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Insert Data Into Keys Table",
        "x": 980,
        "y": 620,
        "wires": [
            [
                "6d0815a5398c0562"
            ],
            [],
            []
        ]
    },
    {
        "id": "142889e16226db05",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Prepare to create Registration Secret Key",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: File paths ---\nconst publicKey = msg.payload.public_key;  // PEM format string\nconst publicKeyPath = '/etc/mosquitto/certs/sunny-public-key.pem';\nconst privateKeyPath = '/etc/mosquitto/certs/alice-private-key.pem';\nconst secretKeyPath = '/etc/mosquitto/certs/alice-registration-secret-key.bin';\n\n// --- Step 2: Write Sunny's public key to file ---\nfs.writeFileSync(publicKeyPath, publicKey, 'utf8');\nnode.log(`‚úÖ Public key saved to ${publicKeyPath}`);\n\n// --- Step 3: Prepare OpenSSL command for Exec node ---\nmsg.payload = `openssl pkeyutl -derive -inkey ${privateKeyPath} -peerkey ${publicKeyPath} -out ${secretKeyPath}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 400,
        "wires": [
            [
                "503e886a69e6d8d3"
            ]
        ]
    },
    {
        "id": "503e886a69e6d8d3",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create Registration Secret Key",
        "x": 810,
        "y": 380,
        "wires": [
            [
                "c6d35c8c7661e0a2"
            ],
            [],
            []
        ]
    },
    {
        "id": "b3c1f8a87f6179c6",
        "type": "comment",
        "z": "dbfebf7401afce77",
        "name": "MQTT Client (Alice)",
        "info": "",
        "x": 130,
        "y": 140,
        "wires": []
    },
    {
        "id": "6d0815a5398c0562",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Trust CA",
        "func": "const caUrl = global.get('ca_url', 'file');\nconst fp    = global.get('fingerprint', 'file');\n\nif (!caUrl || !fp) {\n  node.error('Missing ca_url or fingerprint in global(file) context');\n  return null;\n}\n\n// One single line, no line breaks:\nmsg.payload = `step ca bootstrap --ca-url \"${caUrl}\" --fingerprint \"${fp}\" --install --force`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 520,
        "wires": [
            [
                "528867595ec401bd"
            ]
        ]
    },
    {
        "id": "528867595ec401bd",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Trust CA",
        "x": 1280,
        "y": 600,
        "wires": [
            [
                "b0708970d9969a36"
            ],
            [],
            []
        ]
    },
    {
        "id": "b0708970d9969a36",
        "type": "function",
        "z": "dbfebf7401afce77",
        "name": "Prepare to create MQTTS key and certificate",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: File paths ---\nconst certPath = '/etc/mosquitto/certs/alice.pem';\nconst keyPath = '/etc/mosquitto/certs/alice-key.pem';\nconst provPassFile = '/etc/mosquitto/certs/provisioner_password';\n\n// --- Step 2: Prepare step-ca command for Exec node ---\nmsg.payload = `step ca certificate alice \\\n${certPath} \\\n${keyPath} \\\n--provisioner \"Admin JWK\" \\\n--provisioner-password-file ${provPassFile} \\\n--force`;\nnode.warn(\"Registration Completed\");\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1530,
        "y": 580,
        "wires": [
            [
                "e9bb808b41f576d5"
            ]
        ]
    },
    {
        "id": "e9bb808b41f576d5",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create MQTTS key and cerificate",
        "x": 1540,
        "y": 500,
        "wires": [
            [
                "d411fbab249086c2"
            ],
            [],
            []
        ]
    },
    {
        "id": "4ff2482c3af418be",
        "type": "inject",
        "z": "dbfebf7401afce77",
        "name": "Start Registration",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 140,
        "y": 260,
        "wires": [
            [
                "8efd17ed78926cf4"
            ]
        ]
    },
    {
        "id": "d411fbab249086c2",
        "type": "exec",
        "z": "dbfebf7401afce77",
        "command": "sudo systemctl restart mosquitto-cert-renew.service | sudo systemctl kill -s HUP mosquitto",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Restart renew service",
        "x": 1900,
        "y": 500,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "9e0676afdb26f148",
        "type": "inject",
        "z": "dbfebf7401afce77",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 840,
        "y": 460,
        "wires": [
            [
                "c6d35c8c7661e0a2"
            ]
        ]
    },
    {
        "id": "873502a2020d1559",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]