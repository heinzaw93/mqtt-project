[
    {
        "id": "4bb7ca8ffb3f347a",
        "type": "tab",
        "label": "Rotation and Revocation",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "1d0b4865214ca12d",
        "type": "mqtt in",
        "z": "4bb7ca8ffb3f347a",
        "name": "Revoke MQTTS",
        "topic": "revoke/MQTTS/cake",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "169a731302eeb663",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 140,
        "wires": [
            [
                "f3468f8e80cd7684"
            ]
        ]
    },
    {
        "id": "f3468f8e80cd7684",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Prepare bootstrap to trust CA",
        "func": "const fs = global.get('fs');\nconst caUrl = msg.payload.ca_url;\nconst fp    = msg.payload.fingerprint;\nconst prov_pass = msg.payload.prov_pass;\nconst MQTTS_CA_Certificate =msg.payload.MQTTS_CA_Certificate;\nconst prov_pass_path = \"/etc/mosquitto/certs/provisioner_password\";\nconst MQTTScertFilePath = \"/etc/mosquitto/certs/MQTTS.pem\";\nfs.writeFileSync(prov_pass_path, prov_pass, 'utf8');\nfs.writeFileSync(MQTTScertFilePath, MQTTS_CA_Certificate, 'utf8');\nif (!caUrl || !fp) {\n  node.error('Missing ca_url or fingerprint in Payload');\n  return null;\n}\n\n// One single line, no line breaks:\nmsg.payload = `step ca bootstrap --ca-url \"${caUrl}\" --fingerprint \"${fp}\" --install --force`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 460,
        "y": 160,
        "wires": [
            [
                "ca689abb099baa41"
            ]
        ]
    },
    {
        "id": "ca689abb099baa41",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Trust CA",
        "x": 760,
        "y": 120,
        "wires": [
            [
                "7ca890e164cf818c"
            ],
            [],
            []
        ]
    },
    {
        "id": "7ca890e164cf818c",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Prepare to create MQTTS key and certificate",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: File paths ---\nconst certPath = '/etc/mosquitto/certs/cake.pem';\nconst keyPath = '/etc/mosquitto/certs/cake-key.pem';\nconst provPassFile = '/etc/mosquitto/certs/provisioner_password';\n\n// --- Step 2: Prepare step-ca command for Exec node ---\nmsg.payload = `step ca certificate cake \\\n${certPath} \\\n${keyPath} \\\n--san cake \\\n--san 192.168.154.1 \\\n--provisioner \"Admin JWK\" \\\n--provisioner-password-file ${provPassFile} \\\n--force`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 100,
        "wires": [
            [
                "f56966080af35b8a"
            ]
        ]
    },
    {
        "id": "f56966080af35b8a",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create MQTTS key and cerificate",
        "x": 1440,
        "y": 100,
        "wires": [
            [
                "1f48a4cb2ae6cda8"
            ],
            [],
            []
        ]
    },
    {
        "id": "1f48a4cb2ae6cda8",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "sudo systemctl restart mosquitto-cert-renew.service | sudo systemctl kill -s HUP mosquitto",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Restart renew service",
        "x": 1720,
        "y": 80,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "9c4ef8965e8ade46",
        "type": "mqtt in",
        "z": "4bb7ca8ffb3f347a",
        "name": "Renew ECC keys",
        "topic": "renew/ECC/cake",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "169a731302eeb663",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 360,
        "wires": [
            [
                "fc252cd9a2db9403",
                "654d6de1b1fb5a87"
            ]
        ]
    },
    {
        "id": "fc252cd9a2db9403",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Match ID",
        "func": "// === Step 1: Get stored device_id from global ===\nconst storedDeviceId = global.get(\"deviceID\", \"file\");   // from global.set(..., 'file')\n\n// === Step 2: Get incoming device_id ===\nconst incomingDeviceId = msg.payload.device_id;\n\n// === Step 3: Compare ===\nif (storedDeviceId && incomingDeviceId && storedDeviceId === incomingDeviceId) {\n    // ✅ IDs match\n    const deviceName = msg.payload.device_name || \"unknown\";\n    flow.set('deviceName', deviceName);\n    const privateKeyPath = `/etc/mosquitto/certs/${deviceName}-private-key.pem`;\n\n    // Exec node needs plain string\n    msg.payload = `openssl ecparam -genkey -name prime256v1 -out ${privateKeyPath}`;\n\n    return msg;\n} else {\n    node.warn(`❌ Device ID mismatch! Stored=${storedDeviceId}, Incoming=${incomingDeviceId}`);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 340,
        "wires": [
            [
                "343b7962271d7aca"
            ]
        ]
    },
    {
        "id": "343b7962271d7aca",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Cake private key creation",
        "x": 610,
        "y": 360,
        "wires": [
            [
                "0a8ab04fb64b0bcd"
            ],
            [],
            []
        ]
    },
    {
        "id": "36a0c694ea578a69",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Insert Data Into Keys Table",
        "x": 1680,
        "y": 300,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "1211e69491de0f54",
        "type": "change",
        "z": "4bb7ca8ffb3f347a",
        "name": "Set MQTTS Payload to sync database",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1570,
        "y": 420,
        "wires": [
            [
                "5c7e526e25f45b9f"
            ]
        ]
    },
    {
        "id": "5c7e526e25f45b9f",
        "type": "mqtt out",
        "z": "4bb7ca8ffb3f347a",
        "name": "Sync Keys Table",
        "topic": "sync/data/keys_",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d56a7829b8c5382e",
        "x": 1840,
        "y": 400,
        "wires": []
    },
    {
        "id": "51cad09eb792d333",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Read keys and prepare data for Keys Table",
        "func": "// --- Simple combined function ---\n// 1) Read files -> put in global\n// 2) Build SQL -> put string cmd into msg.payload\n\nconst fs = global.get('fs');\nif (!fs) { node.error(\"fs not found in global (set with global.set('fs', require('fs')) )\"); return null; }\n\nconst dbPath     = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey  = env.get(\"DB_PASSWORD\");\nif (!pragmaKey) { node.error(\"DB_PASSWORD env not set\"); return null; }\n\n// === Paths ===\nconst publicKeyPath  = \"/etc/mosquitto/certs/cake-public-key.pem\";\nconst privateKeyPath = \"/etc/mosquitto/certs/cake-private-key.pem\";\nconst secretKeyPath  = \"/etc/mosquitto/certs/cake-registration-secret-key.bin\";\n\n// --- Step 1: Read PEMs and store to global ---\nlet publicKey, privateKey;\ntry {\n  publicKey  = fs.readFileSync(publicKeyPath, 'utf8').trim();\n  privateKey = fs.readFileSync(privateKeyPath, 'utf8').trim();\n} catch (e) {\n  node.error(\"Read PEM failed: \" + e.message);\n  return null;\n}\nglobal.set(\"public_key\",  publicKey,  \"file\");\nglobal.set(\"private_key\", privateKey, \"file\");\n\n// --- Step 2: Get deviceID (already set elsewhere) ---\nconst deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) { node.error(\"deviceID not found in global context\"); return null; }\n\n// --- Step 3: Read registration secret (binary) ---\nlet secretBuf;\ntry {\n  secretBuf = fs.readFileSync(secretKeyPath);  // raw binary\n} catch (e) {\n  node.error(\"Read registration secret failed: \" + e.message);\n  return null;\n}\nconst secretHex = secretBuf.toString('hex');\n\n// --- Step 4: Build SQL (escape single quotes in PEMs) ---\nconst esc = s => s.replace(/'/g, \"''\");\nconst sql = `\nPRAGMA key='${pragmaKey}';\nINSERT OR REPLACE INTO Keys (device_id, private_key, public_key, registration_key)\nVALUES ('${esc(deviceID)}', '${esc(privateKey)}', '${esc(publicKey)}', X'${secretHex}');\n`.trim();\n\nconst deviceName = flow.get('deviceName');\n// --- Step 5: Prepare exec command (must be a plain string) ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sql}\"`;\n\nmsg.mqtt_payload = {\n    device_id: deviceID,\n    devicename:deviceName,\n    public_key: publicKey\n    // Optionally, use Base64 instead: secretKeyBuffer.toString('base64')\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1250,
        "y": 340,
        "wires": [
            [
                "36a0c694ea578a69",
                "1211e69491de0f54"
            ]
        ]
    },
    {
        "id": "0a8ab04fb64b0bcd",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "openssl ec -in /etc/mosquitto/certs/cake-private-key.pem -pubout -out /etc/mosquitto/certs/cake-public-key.pem",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create Cake Public Key ",
        "x": 890,
        "y": 360,
        "wires": [
            [
                "51cad09eb792d333"
            ],
            [],
            []
        ]
    },
    {
        "id": "494f7f76c9fe988e",
        "type": "inject",
        "z": "4bb7ca8ffb3f347a",
        "name": "Renew JWT",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "300",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 160,
        "y": 620,
        "wires": [
            [
                "5f3e64b4203f90b6"
            ]
        ]
    },
    {
        "id": "5f3e64b4203f90b6",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Prepare to Select JWT",
        "func": "const dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 1: Get deviceID from global context ---\nlet deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) {\n    node.error(\"❌ deviceID not found in global context.\");\n    return null;\n}\n\n// --- Step 2: Escape single quotes ---\ndeviceID = deviceID.replace(/'/g, \"''\");\n\n// --- Step 3: Build SELECT query (only jwt_token) ---\nconst sqlSelect = `\nPRAGMA key = '${pragmaKey}';\nSELECT jwt_token \nFROM DeviceProfile \nWHERE device_id = '${deviceID}';\n`;\n\n// --- Step 4: Send command to exec node ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlSelect.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 580,
        "wires": [
            [
                "062cdecf493b31f4"
            ]
        ]
    },
    {
        "id": "062cdecf493b31f4",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Select JWT",
        "x": 650,
        "y": 600,
        "wires": [
            [
                "ba1e51dd67be8a3b"
            ],
            [],
            []
        ]
    },
    {
        "id": "ba1e51dd67be8a3b",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Validate JWT expire",
        "func": "// Input: msg.payload = JWT string (may include surrounding quotes from sqlcipher)\n// Output (when ttl < 60): msg.payload = { device_id, jwt }\n\nconst deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) { node.error(\"deviceID not found in global context\"); return null; }\n\n// 1) Get token string\nlet token = (msg.payload ?? \"\").toString().trim();\n// strip surrounding quotes if present\nif (token.startsWith('\"') && token.endsWith('\"')) token = token.slice(1, -1);\n\n// basic check\nif (!token || !token.includes(\".\")) { node.error(\"Invalid JWT\"); return null; }\n\n// 2) Decode base64url payload\nfunction b64urlToJson(b64u) {\n  const b64 = b64u.replace(/-/g, '+').replace(/_/g, '/');\n  const pad = (4 - (b64.length % 4)) % 4;\n  return JSON.parse(Buffer.from(b64 + \"=\".repeat(pad), \"base64\").toString(\"utf8\"));\n}\n\ntry {\n  const parts = token.split(\".\");\n  if (parts.length < 2) { node.error(\"Malformed JWT\"); return null; }\n  const claims = b64urlToJson(parts[1]);\n\n  const now = Math.floor(Date.now() / 1000);\n  const iat = Number(claims.iat || 0);\n  const exp = Number(claims.exp || 0);\n  const ttl = Math.max(0, exp - now);\n\n  if (!iat || !exp) { node.error(\"JWT missing iat/exp\"); return null; }\n\n  if (ttl < 60) {\n    // need refresh -> pass device_id and token forward\n    msg.payload = { device_id: deviceID, jwt: token };\n    return msg;\n  } else {\n    node.warn(`jwt is still valid (ttl_seconds=${ttl})`);\n    return null; // stop here\n  }\n} catch (e) {\n  node.error(\"Failed to decode JWT: \" + e.message);\n  return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 920,
        "y": 600,
        "wires": [
            [
                "eb019183c53610f2"
            ]
        ]
    },
    {
        "id": "eb019183c53610f2",
        "type": "mqtt out",
        "z": "4bb7ca8ffb3f347a",
        "name": "Request to renew JWT",
        "topic": "renew/jwt/cake",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "169a731302eeb663",
        "x": 1200,
        "y": 560,
        "wires": []
    },
    {
        "id": "39f249cec3322ecb",
        "type": "mqtt in",
        "z": "4bb7ca8ffb3f347a",
        "name": "Respond new JWT",
        "topic": "respond/jwt/cake",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "169a731302eeb663",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 780,
        "wires": [
            [
                "e79aae6629cc40ee"
            ]
        ]
    },
    {
        "id": "4b14425359428444",
        "type": "exec",
        "z": "4bb7ca8ffb3f347a",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update JWT",
        "x": 910,
        "y": 760,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "9ea241647080ab12",
        "type": "mqtt in",
        "z": "4bb7ca8ffb3f347a",
        "name": "Renew JWT",
        "topic": "renew/JWT/cake",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "169a731302eeb663",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 130,
        "y": 520,
        "wires": [
            [
                "5f3e64b4203f90b6"
            ]
        ]
    },
    {
        "id": "6269f7d13006df26",
        "type": "comment",
        "z": "4bb7ca8ffb3f347a",
        "name": "MQTT Bridge Broker (Cake)",
        "info": "",
        "x": 200,
        "y": 40,
        "wires": []
    },
    {
        "id": "440629a9ff087e90",
        "type": "comment",
        "z": "4bb7ca8ffb3f347a",
        "name": "Revoke MQTTS Certs and Key",
        "info": "",
        "x": 230,
        "y": 100,
        "wires": []
    },
    {
        "id": "da3f53fcfb4f6d76",
        "type": "comment",
        "z": "4bb7ca8ffb3f347a",
        "name": "Renew Keys",
        "info": "",
        "x": 130,
        "y": 280,
        "wires": []
    },
    {
        "id": "cbdf40c0492359ff",
        "type": "comment",
        "z": "4bb7ca8ffb3f347a",
        "name": "Renew JWT",
        "info": "",
        "x": 150,
        "y": 460,
        "wires": []
    },
    {
        "id": "0b7584a8f19bba34",
        "type": "comment",
        "z": "4bb7ca8ffb3f347a",
        "name": "Recieved new JWT",
        "info": "",
        "x": 150,
        "y": 720,
        "wires": []
    },
    {
        "id": "e79aae6629cc40ee",
        "type": "function",
        "z": "4bb7ca8ffb3f347a",
        "name": "Validate JWT and prepare to update database",
        "func": "const fs        = global.get('fs');\nconst jwt       = global.get('jwt');\nconst crypto    = global.get('crypto');\n\nconst dbPath    = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 1: Get incoming payload ---\nconst payload          = msg.payload || {};\nconst incomingDeviceId = payload.device_id;\nconst newJwt           = payload.jwt;\nconst signatureB64     = payload.jwt_sig_b64;    // expecting signature field\n\n// --- Step 2: Get stored deviceId ---\nlet storedDeviceId = global.get(\"deviceID\", \"file\");\nif (!storedDeviceId) {\n    node.error(\"❌ deviceID not found in global context\");\n    return null;\n}\n\n// --- Step 3: Compare IDs ---\nif (incomingDeviceId !== storedDeviceId) {\n    node.warn(`❌ Device ID mismatch. Incoming=${incomingDeviceId}, Stored=${storedDeviceId}`);\n    return null;\n}\n\n// --- Step 4: Verify signature over (device_id | jwt) ---\nif (!signatureB64) {\n    node.warn(\"❌ Missing jwt_sig_b64 in payload\");\n    return null;\n}\n\nlet sunnyPub;\ntry {\n    sunnyPub = fs.readFileSync(\"/etc/mosquitto/certs/sunny-public-key.pem\", \"utf8\");\n} catch (e) {\n    node.error(\"❌ Unable to read sunny-public-key.pem: \" + e.message);\n    return null;\n}\n\nconst verify = crypto.createVerify(\"sha256\");\nverify.update(`${incomingDeviceId}|${newJwt}`);\nverify.end();\n\nlet sigOK;\ntry {\n    sigOK = verify.verify(sunnyPub, signatureB64, \"base64\");\n} catch (e) {\n    node.warn(\"❌ Signature verification error: \" + e.message);\n    return null;\n}\n\nif (!sigOK) {\n    node.warn(\"❌ Signature invalid for device_id and jwt.\");\n    return null;\n}\nnode.warn(`✅ Signature verified new JWT come from Sunny for device_id=${incomingDeviceId}`);\n\n// --- Step 5: Escape values for SQL ---\nconst esc = s => (s ?? \"\").toString().replace(/'/g, \"''\");\nconst sqlUpdate = `\nPRAGMA key='${pragmaKey}';\nUPDATE DeviceProfile\nSET jwt_token='${esc(newJwt)}'\nWHERE device_id='${esc(storedDeviceId)}';\n`.trim();\n\n// --- Step 6: Prepare exec payload ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlUpdate}\"`;\n\nnode.warn(`✅ JWT updated for device_id: ${storedDeviceId}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 780,
        "wires": [
            [
                "4b14425359428444"
            ]
        ]
    },
    {
        "id": "654d6de1b1fb5a87",
        "type": "debug",
        "z": "4bb7ca8ffb3f347a",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 360,
        "y": 420,
        "wires": []
    },
    {
        "id": "169a731302eeb663",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.154.1",
        "port": "8883",
        "tls": "5e68294b47c958cb",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "d56a7829b8c5382e",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.154.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "5e68294b47c958cb",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cake.pem",
        "key": "/etc/mosquitto/certs/cake-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cake",
        "verifyservercert": true,
        "alpnprotocol": ""
    }
]