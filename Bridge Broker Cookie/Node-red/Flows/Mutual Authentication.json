[
    {
        "id": "2a0e24ae5492f4f9",
        "type": "tab",
        "label": "Mutual Authentication",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "63033d398bec4e1f",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "iwgetid -r",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Check Network",
        "x": 540,
        "y": 160,
        "wires": [
            [
                "a815317ae1019aaa"
            ],
            [],
            []
        ]
    },
    {
        "id": "1f9b53f0fd6242c9",
        "type": "inject",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Timer",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "360",
        "crontab": "",
        "once": false,
        "onceDelay": "120",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 260,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "c425cafccf7bdbd6",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Get JWT",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// Step 0: Debug the raw result from SQLCipher\n//node.warn(\"Received Data: \" + msg.payload);\n\n// Step 1: Split the payload by '|'\nconst parts = msg.payload.trim().split('|');\nif (parts.length !== 2) {\n    node.error(\"Payload is not in expected 'device_id|jwt_token' format.\");\n    return null;\n}\n\nconst [device_id, jwt_token] = parts;\n\n// Step 2: Validate parsed data\nif (!device_id || !jwt_token) {\n    node.error(\"Missing device_id or jwt_token in result.\");\n    return null;\n}\n\n// Step 3: Prepare data to sign\nconst dataToSign = `${device_id}|${jwt_token}`;\n\n// Step 4: Load Cookie‚Äôs private key from global context\nlet privateKeyPEM = global.get(\"private_key\", \"file\");\nif (!privateKeyPEM) {\n    node.error(\"‚ùå Cookie's private key not found in global context!\");\n    return null;\n}\n\n// Step 5: Sign the data using ECDSA (SHA-256)\nconst signer = crypto.createSign('sha256');\nsigner.update(dataToSign);\nsigner.end();\nconst signature = signer.sign(privateKeyPEM, 'base64');\n\n// Step 6: Get wifi_SSID from flow context\nconst wifi_SSID = flow.get('wifi_ssid');\n\nif (!wifi_SSID) {\n    node.warn(\"‚ö†Ô∏è wifi_SSID not set in flow context.\");\n} else {\n   // node.warn(\"‚úÖ Retrieved wifi_SSID from flow context: \" + wifi_SSID);\n}\n\n// Step 7: Return structured payload\nmsg.payload = {\n    device_id: device_id,\n    jwt: jwt_token,\n    signature: signature,\n    wifi_SSID: wifi_SSID || \"UNKNOWN\"\n};\n\n//node.warn(\"üì¶ Signed Payload with SSID: \" + JSON.stringify(msg.payload));\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 160,
        "wires": [
            [
                "f61f8169ab3af61f"
            ]
        ]
    },
    {
        "id": "a815317ae1019aaa",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Prepare Query to select JWT ",
        "func": "// === 1. Get SSID and store in flow context ===\nlet ssid = msg.payload.trim();\nflow.set('wifi_ssid', ssid);\nnode.status({fill: \"green\", shape: \"dot\", text: \"Connected to SSID: \" + ssid});\n\n// === 2. Get deviceID from global context with retries ===\nlet deviceID;\nlet attempts = 0;\n\nwhile (!deviceID && attempts < 5) {\n    deviceID = global.get(\"deviceID\", \"file\");\n    if (!deviceID) {\n        node.warn(\"Retrying retrieval of deviceID...\");\n        attempts++;\n        const waitUntil = Date.now() + 200;\n        while (Date.now() < waitUntil); // busy-wait 200ms\n    }\n}\n\nif (!deviceID) {\n    node.error(\"Device ID still not found in global context!\");\n    return null;\n}\n\n// === 3. Prepare SQL query for sqlcipher ===\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// Escape quotes in deviceID to avoid SQL injection\ndeviceID = deviceID.replace(/'/g, \"''\");\n\n// Build SQLCipher SELECT command for DeviceProfile table\nconst sqlSelect = `\nPRAGMA key = '${pragmaKey}';\nSELECT device_id, jwt_token FROM DeviceProfile WHERE device_id = '${deviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlSelect.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 100,
        "wires": [
            [
                "6687521049543968"
            ]
        ]
    },
    {
        "id": "5e9ed4d99552d292",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Request to Sunny",
        "topic": "authentication/request/cookie",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "72399054283f9843",
        "x": 1480,
        "y": 100,
        "wires": []
    },
    {
        "id": "6687521049543968",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Select JWT Token",
        "x": 810,
        "y": 180,
        "wires": [
            [
                "c425cafccf7bdbd6"
            ],
            [],
            []
        ]
    },
    {
        "id": "f13937e258ae4822",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update authentication status and select public key",
        "x": 1050,
        "y": 360,
        "wires": [
            [
                "7847d01ad2184a94"
            ],
            [],
            []
        ]
    },
    {
        "id": "2ca0301fcffe5cfe",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Request to Cake",
        "topic": "authentication/request/cookie",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fc5713ddc872ba82",
        "x": 1470,
        "y": 220,
        "wires": []
    },
    {
        "id": "f61f8169ab3af61f",
        "type": "switch",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "property": "payload.wifi_SSID",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Network-01",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-02",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-B",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 1230,
        "y": 160,
        "wires": [
            [
                "5e9ed4d99552d292"
            ],
            [
                "5e9ed4d99552d292"
            ],
            [
                "2ca0301fcffe5cfe"
            ]
        ]
    },
    {
        "id": "b689d80fe5b4efc2",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "Publish JWT to host device to authenticate",
        "info": "",
        "x": 340,
        "y": 100,
        "wires": []
    },
    {
        "id": "7847d01ad2184a94",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Verify Signature/ JWT and prepare query to update authentication status",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\nconst jwt = global.get('jwt');\n\n// --- Step 1: Setup ---\nconst deviceName = msg.device_name;\nconst deviceID = flow.get('deviceID');\nconst dataToVerify = flow.get('dataToVerify');\nconst signature = flow.get('signature');\nconst token = flow.get('jwt');\n\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\nlet authenticationStatus = \"\";  // Will be set dynamically\n\n// --- Step 2: Parse SQLCipher result to extract public key ---\nconst publicKey = msg.payload.trim();\nif (!publicKey.startsWith(\"-----BEGIN PUBLIC KEY-----\")) {\n    node.error(\"‚ùå SQLCipher result is not a valid public key.\");\n    authenticationStatus = \"Signature fail\";\n} else {\n    try {\n        const verifier = crypto.createVerify('sha256');\n        verifier.update(dataToVerify);\n        verifier.end();\n        const isValid = verifier.verify(publicKey, signature, 'base64');\n\n        if (!isValid) {\n            node.warn(\"‚ùå Signature verification failed.\");\n            authenticationStatus = \"Signature fail\";\n        } else {\n            node.warn(\"‚úÖ Signature verification successful.\");\n\n            // --- Step 3: Verify JWT using Sunny's public key + enforce 45-min window ---\n            try {\n                const sunnyPublicKeyPath = \"/etc/mosquitto/certs/sunny-public-key.pem\";\n                const sunnyPublicKey = fs.readFileSync(sunnyPublicKeyPath, 'utf8');\n\n                // Signature + 'exp' in future\n                const decodedJWT = jwt.verify(token, sunnyPublicKey, { algorithms: ['ES256'] });\n\n                // Enforce max lifetime of 45 minutes\n                const iat = Number(decodedJWT.iat || 0);\n                const exp = Number(decodedJWT.exp || 0);\n                const lifetime = exp - iat;\n\n                if (!iat || !exp || lifetime <= 0 || lifetime > 2700) {\n                    node.warn(\"‚ùå JWT invalid window (must be ‚â§ 2700s).\");\n                    authenticationStatus = \"JWT fail\";\n                } else if (decodedJWT.device_id !== deviceID) {\n                    node.warn(\"‚ùå JWT device ID mismatch.\");\n                    authenticationStatus = \"JWT fail\";\n                } else {\n                    node.warn(\"‚úÖ JWT verification successful (‚â§45 min).\");\n                    authenticationStatus = \"OK\";\n                }\n            } catch (jwtErr) {\n                node.warn(\"‚ùå JWT verification failed: \" + jwtErr.message);\n                authenticationStatus = \"JWT fail\";\n            }\n        }\n    } catch (sigErr) {\n        node.error(\"‚ùå Signature verification error: \" + sigErr.message);\n        authenticationStatus = \"Signature fail\";\n    }\n}\n\n// --- Step 4: Save status in flow ---\nflow.set('authentication_status', authenticationStatus);\n\n// --- Step 5: Prepare SQL update only ---\nconst updateSQL = `\nPRAGMA key = '${pragmaKey}';\nUPDATE DeviceProfile \nSET authentication_status = '${authenticationStatus}' \nWHERE device_id = '${deviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${updateSQL.trim()}\"`;\n\nnode.warn(`üìå authentication_status = \"${authenticationStatus}\" set for device_id: ${deviceID}`);\n\nmsg.mqtt_payload = {\n    device_id: deviceID,\n    authentication_status: authenticationStatus\n    \n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1340,
        "y": 480,
        "wires": [
            [
                "9354c79075a49546",
                "9a08dd322fe14549"
            ]
        ]
    },
    {
        "id": "9354c79075a49546",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update Authentication Status",
        "x": 1500,
        "y": 600,
        "wires": [
            [
                "2ee0c9ca2f505a65"
            ],
            [],
            []
        ]
    },
    {
        "id": "2eae86f921d4bcc2",
        "type": "mqtt in",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Respond",
        "topic": "authentication/respond/cookie",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "fc5713ddc872ba82",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 560,
        "wires": [
            [
                "93ecd39c7ec78d61"
            ]
        ]
    },
    {
        "id": "93ecd39c7ec78d61",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Save MQTT payload in flow and prepare query to update authentication status to select the public-key",
        "func": "// --- Step 1: Extract payload from MQTT topic ---\nlet topicParts = msg.topic.split(\"/\");\nmsg.device_name = topicParts[2];  // Extract device name from topic\n\n// --- Step 2: Extract values from MQTT payload ---\nconst deviceID = msg.payload.device_id;\nconst token = msg.payload.jwt;\nconst signature = msg.payload.signature;\nconst authentication_status= msg.payload.authentication_status\n// --- Retrieve self device_id from global context ---\nconst selfDeviceID = global.get(\"deviceID\", \"file\");\n\n// --- Step 3: Validate payload ---\nif (!deviceID || !token || !signature || !authentication_status) {\n    node.error(\"‚ùå Missing required payload values: device_id, jwt, or signature or authentication_status.\");\n    return null;\n}\n\n// --- Step 4: Store values in flow context (do NOT save wifi_SSID) ---\nflow.set('deviceID', deviceID);\nflow.set('jwt', token);\nflow.set('signature', signature);\n\n// --- Step 5: Construct data to verify and store it ---\nconst dataToVerify = `${deviceID}|${token}`;\nflow.set('dataToVerify', dataToVerify);\n\n// --- Step 6: Prepare SQLCipher query to retrieve public_key from DeviceProfile ---\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// Sanitize deviceID for SQL\nconst safeDeviceID = deviceID.replace(/'/g, \"''\");\nconst updateSQL = `\nPRAGMA key = '${pragmaKey}';\nUPDATE DeviceProfile \nSET authentication_status = '${authentication_status}' \nWHERE device_id = '${selfDeviceID}';\n`;\nconst sqlQuery = `\nPRAGMA key = '${pragmaKey}';\nSELECT public_key FROM Keys WHERE device_id = '${safeDeviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlQuery.trim()}\\n ${updateSQL.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 480,
        "wires": [
            [
                "f13937e258ae4822"
            ]
        ]
    },
    {
        "id": "2ee0c9ca2f505a65",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Prepare MQTT payload for authentication respond-ack",
        "func": "// ‚úÖ Step 1: Get device name\nconst deviceName = msg.device_name;\nconst deviceID = flow.get('deviceID');\nconst authentication_status = flow.get('authentication_status');\nmsg.topic = `authentication/respond_ack/${deviceName}`;\n\nconst wifi_SSID = flow.get('wifi_ssid');\n\nif (!wifi_SSID) {\n    node.warn(\"‚ö†Ô∏è wifi_SSID not set in flow context.\");\n} else {\n    //node.warn(\"‚úÖ Retrieved wifi_SSID from flow context: \" + wifi_SSID);\n}\n// --- Step 5: Prepare MQTT payload ---\nmsg.payload = {\n    device_id: deviceID,\n    wifi_SSID: wifi_SSID || \"UNKNOWN\",\n    authentication_status: authentication_status\n};\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2020,
        "y": 540,
        "wires": [
            [
                "02f9b1d89f56704c"
            ]
        ]
    },
    {
        "id": "8cec172b314d43c9",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Ack to Sunny",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "72399054283f9843",
        "x": 2400,
        "y": 400,
        "wires": []
    },
    {
        "id": "714efb57a4e40608",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Ack to Cake",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fc5713ddc872ba82",
        "x": 2480,
        "y": 540,
        "wires": []
    },
    {
        "id": "5ec1368f4867129c",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "Authenticate connected Devices",
        "info": "",
        "x": 290,
        "y": 940,
        "wires": []
    },
    {
        "id": "11df88232a5f1fb1",
        "type": "mqtt in",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Request",
        "topic": "authentication/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 1040,
        "wires": [
            [
                "e299ef03d6e0afa5"
            ]
        ]
    },
    {
        "id": "e299ef03d6e0afa5",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Save MQTT paylod in flow and Query out Public Key",
        "func": "\n\n// --- Step 1: Extract payload from MQTT topic ---\nlet topicParts = msg.topic.split(\"/\");\nmsg.device_name = topicParts[2];  // Extract device name from topic\n\n// --- Step 2: Extract values from MQTT payload ---\nconst deviceID = msg.payload.device_id;\nconst token = msg.payload.jwt;\nconst signature = msg.payload.signature;\n\n// --- Step 3: Validate payload ---\nif (!deviceID || !token || !signature) {\n    node.error(\"‚ùå Missing required payload values: device_id, jwt, or signature.\");\n    return null;\n}\n\n// --- Step 4: Store values in flow context (do NOT save wifi_SSID) ---\nflow.set('deviceID', deviceID);\nflow.set('jwt', token);\nflow.set('signature', signature);\n\n// --- Step 5: Construct data to verify and store it ---\nconst dataToVerify = `${deviceID}|${token}`;\nflow.set('dataToVerify', dataToVerify);\n\n// --- Step 6: Prepare SQLCipher query to retrieve public_key from DeviceProfile ---\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// Sanitize deviceID for SQL\nconst safeDeviceID = deviceID.replace(/'/g, \"''\");\n\nconst sqlQuery = `\nPRAGMA key = '${pragmaKey}';\nSELECT public_key FROM Keys WHERE device_id = '${safeDeviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlQuery.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1040,
        "wires": [
            [
                "acc532c681e47684"
            ]
        ]
    },
    {
        "id": "72839aba969b120e",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Verify Signature/ JWT and prepare query to update authentication status/ select JWT",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\nconst jwt = global.get('jwt');\n\n// --- Step 1: Setup ---\nconst deviceName = msg.device_name;\nconst deviceID = flow.get('deviceID');\nconst dataToVerify = flow.get('dataToVerify');\nconst signature = flow.get('signature');\nconst token = flow.get('jwt');\n\n// --- Retrieve self device_id from global context ---\nconst selfDeviceID = global.get(\"deviceID\", \"file\");\n\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\nlet authenticationStatus = \"\";  // Will be set dynamically\n\n// --- Step 2: Parse SQLCipher result to extract public key ---\nconst publicKey = (msg.payload || \"\").toString().trim();\nif (!publicKey.startsWith(\"-----BEGIN PUBLIC KEY-----\")) {\n    node.error(\"‚ùå SQLCipher result is not a valid public key.\");\n    authenticationStatus = \"Signature fail\";\n} else {\n    try {\n        const verifier = crypto.createVerify('sha256');\n        verifier.update(dataToVerify);\n        verifier.end();\n        const isValid = verifier.verify(publicKey, signature, 'base64');\n\n        if (!isValid) {\n            node.warn(\"‚ùå Signature verification failed.\");\n            authenticationStatus = \"Signature fail\";\n        } else {\n            node.warn(\"‚úÖ Signature verification successful.\");\n\n            // --- Step 3: Verify JWT using Sunny's public key + enforce 45-min window ---\n            try {\n                const sunnyPublicKeyPath = \"/etc/mosquitto/certs/sunny-public-key.pem\";\n                const sunnyPublicKey = fs.readFileSync(sunnyPublicKeyPath, 'utf8');\n\n                // Signature + 'exp' in future\n                const decodedJWT = jwt.verify(token, sunnyPublicKey, { algorithms: ['ES256'] });\n\n                // Enforce max lifetime of 15 minutes\n                const iat = Number(decodedJWT.iat || 0);\n                const exp = Number(decodedJWT.exp || 0);\n                const lifetime = exp - iat;\n\n                if (!iat || !exp || lifetime <= 0 || lifetime > 2700) {\n                    node.warn(\"‚ùå JWT invalid window (must be ‚â§ 2700s).\");\n                    authenticationStatus = \"JWT fail\";\n                } else if (decodedJWT.device_id !== deviceID) {\n                    node.warn(\"‚ùå JWT device ID mismatch.\");\n                    authenticationStatus = \"JWT fail\";\n                } else {\n                    node.warn(\"‚úÖ JWT verification successful (‚â§45 min).\");\n                    authenticationStatus = \"OK\";\n                }\n            } catch (jwtErr) {\n                node.warn(\"‚ùå JWT verification failed: \" + jwtErr.message);\n                authenticationStatus = \"JWT fail\";\n            }\n        }\n    } catch (sigErr) {\n        node.error(\"‚ùå Signature verification error: \" + sigErr.message);\n        authenticationStatus = \"Signature fail\";\n    }\n}\n\n// --- Step 4: Save status in flow ---\nflow.set('authentication_status', authenticationStatus);\n\n// --- Step 5: Prepare both queries ---\nconst updateSQL = `\nPRAGMA key = '${pragmaKey}';\nUPDATE DeviceProfile \nSET authentication_status = '${authenticationStatus}' \nWHERE device_id = '${deviceID}';\n`;\n\nconst selectSQL = `\nPRAGMA key = '${pragmaKey}';\nSELECT jwt_token FROM DeviceProfile WHERE device_id = '${selfDeviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${updateSQL.trim()} \\n ${selectSQL.trim()}\"`;\n\nnode.warn(`üìå authentication_status = \"${authenticationStatus}\" set for device_id: ${deviceID}`);\n\nmsg.mqtt_payload = {\n    device_id: deviceID,\n    authentication_status: authenticationStatus\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 1020,
        "wires": [
            [
                "a0fab2a3338e9a6b",
                "5bedace2b2f7e615"
            ]
        ]
    },
    {
        "id": "7a24fafccacb8206",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Prepare for Authentication Respond",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// ‚úÖ Step 1: Get device name\nconst deviceName = msg.device_name;\n// --- Step 1: Clean and extract JWT ---\nconst jwtToken = msg.payload.trim();  // Assuming payload is just the raw JWT string\n\n// --- Step 2: Retrieve context values ---\nconst deviceID = global.get(\"deviceID\", \"file\");\nconst authStatus = flow.get(\"authentication_status\");\n\nif (!jwtToken || !deviceID || !authStatus) {\n    node.error(\"‚ùå Missing required values. JWT, device ID, or auth status is not found.\");\n    return null;\n}\n\n\nnode.warn(\"üì¶ MQTT Payload Ready: \" + JSON.stringify(msg.payload));\n// Step 3: Prepare data to sign\nconst dataToSign = `${deviceID}|${jwtToken}`;\n\n// Step 4: Load Jonny‚Äôs private key from global context\nlet privateKeyPEM = global.get(\"private_key\", \"file\");\nif (!privateKeyPEM) {\n    node.error(\"‚ùå Jonny's private key not found in global context!\");\n    return null;\n}\n\n// Step 5: Sign the data using ECDSA (SHA-256)\nconst signer = crypto.createSign('sha256');\nsigner.update(dataToSign);\nsigner.end();\nconst signature = signer.sign(privateKeyPEM, 'base64');\n\n// ‚úÖ Step 4: Set MQTT topic dynamically\nmsg.topic = `authentication/respond/${deviceName}`;\n\n\n// --- Step 5: Prepare MQTT payload ---\nmsg.payload = {\n    device_id: deviceID,\n    jwt: jwtToken,\n    signature: signature,\n    authentication_status: authStatus\n};\n\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1800,
        "y": 1020,
        "wires": [
            [
                "0e4e0647d288338f"
            ]
        ]
    },
    {
        "id": "0e4e0647d288338f",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Respond",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "9cddc1bd885980b7",
        "x": 2150,
        "y": 1000,
        "wires": []
    },
    {
        "id": "acc532c681e47684",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Select the Public Key",
        "x": 840,
        "y": 1100,
        "wires": [
            [
                "72839aba969b120e"
            ],
            [],
            []
        ]
    },
    {
        "id": "a0fab2a3338e9a6b",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update Authenication status and select JWT",
        "x": 1570,
        "y": 920,
        "wires": [
            [
                "7a24fafccacb8206"
            ],
            [],
            []
        ]
    },
    {
        "id": "5bedace2b2f7e615",
        "type": "change",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1360,
        "y": 1080,
        "wires": [
            [
                "bcf56a5fc7c8795d"
            ]
        ]
    },
    {
        "id": "9a08dd322fe14549",
        "type": "change",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1640,
        "y": 420,
        "wires": [
            [
                "c6d07506dabc6a0d"
            ]
        ]
    },
    {
        "id": "c653b789d48c1c4c",
        "type": "mqtt in",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Ack",
        "topic": "authentication/respond_ack/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 230,
        "y": 1260,
        "wires": [
            [
                "818f19b80c016603"
            ]
        ]
    },
    {
        "id": "818f19b80c016603",
        "type": "function",
        "z": "2a0e24ae5492f4f9",
        "name": "Prepare Query to update authentication status",
        "func": "\n\n// --- Step 1: Extract payload from MQTT topic ---\nlet topicParts = msg.topic.split(\"/\");\nmsg.device_name = topicParts[2];  // Extract device name from topic\n\n// --- Step 2: Extract values from MQTT payload ---\nconst deviceID = msg.payload.device_id;\nconst authentication_status = msg.payload.authentication_status;\n\n\n\n// --- Step 6: Prepare SQLCipher query to retrieve public_key from DeviceProfile ---\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// Sanitize deviceID for SQL\nconst safeDeviceID = deviceID.replace(/'/g, \"''\");\n\nconst sqlQuery = `\nPRAGMA key = '${pragmaKey}';\nUPDATE DeviceProfile \nSET authentication_status = '${authentication_status}' \nWHERE device_id = '${deviceID}';\n`;\n\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlQuery.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 1260,
        "wires": [
            [
                "627f7fe650faea17"
            ]
        ]
    },
    {
        "id": "627f7fe650faea17",
        "type": "exec",
        "z": "2a0e24ae5492f4f9",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update Authentication Status",
        "x": 1040,
        "y": 1260,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "c9e7d49b0edc7967",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Sync Device Profile Table",
        "topic": "sync/database/deviceprofile/auth",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "9cddc1bd885980b7",
        "x": 1650,
        "y": 1160,
        "wires": []
    },
    {
        "id": "d014e8ca64cb5128",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "Sync Authentication Status",
        "topic": "sync/database/deviceprofile/auth",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "9cddc1bd885980b7",
        "x": 1920,
        "y": 320,
        "wires": []
    },
    {
        "id": "bcf56a5fc7c8795d",
        "type": "delay",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "pauseType": "delay",
        "timeout": "10",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1400,
        "y": 1160,
        "wires": [
            [
                "c9e7d49b0edc7967"
            ]
        ]
    },
    {
        "id": "c6d07506dabc6a0d",
        "type": "delay",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "pauseType": "delay",
        "timeout": "20",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 1700,
        "y": 360,
        "wires": [
            [
                "d014e8ca64cb5128"
            ]
        ]
    },
    {
        "id": "f5fda2997f348ff5",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "Do mutual authencation for host and update authenctication status in database",
        "info": "",
        "x": 330,
        "y": 300,
        "wires": []
    },
    {
        "id": "8b7ba24ebd4ab208",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "Recieve authentication status from connected devices ",
        "info": "",
        "x": 460,
        "y": 1160,
        "wires": []
    },
    {
        "id": "84e3525b3a405720",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "MQTT Bridge Broker (Cookie)",
        "info": "",
        "x": 280,
        "y": 40,
        "wires": []
    },
    {
        "id": "4ec3f37363984bce",
        "type": "mqtt in",
        "z": "2a0e24ae5492f4f9",
        "name": "Authentication Respond",
        "topic": "authentication/respond/cookie",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "761c288df6a58e96",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 200,
        "y": 400,
        "wires": [
            [
                "93ecd39c7ec78d61"
            ]
        ]
    },
    {
        "id": "dfd69289f2c78414",
        "type": "inject",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "30",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "iso",
        "payloadType": "date",
        "x": 690,
        "y": 700,
        "wires": [
            [
                "e217c72a349f9db9"
            ]
        ]
    },
    {
        "id": "e217c72a349f9db9",
        "type": "mqtt out",
        "z": "2a0e24ae5492f4f9",
        "name": "heartbeat",
        "topic": "devices/cookie/heartbeat",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "873502a2020d1559",
        "x": 920,
        "y": 720,
        "wires": []
    },
    {
        "id": "bf0ce6acce180c00",
        "type": "comment",
        "z": "2a0e24ae5492f4f9",
        "name": "MQTT Bridge Broker (Cookie)",
        "info": "",
        "x": 280,
        "y": 880,
        "wires": []
    },
    {
        "id": "02f9b1d89f56704c",
        "type": "switch",
        "z": "2a0e24ae5492f4f9",
        "name": "",
        "property": "payload.wifi_SSID",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Network-01",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-02",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-B",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 3,
        "x": 2150,
        "y": 460,
        "wires": [
            [
                "8cec172b314d43c9"
            ],
            [
                "8cec172b314d43c9"
            ],
            [
                "714efb57a4e40608"
            ]
        ]
    },
    {
        "id": "72399054283f9843",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "8883",
        "tls": "b6e1278c5d544171",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "fc5713ddc872ba82",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.154.1",
        "port": "8883",
        "tls": "197fbcc39e6717c7",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "9cddc1bd885980b7",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.153.1",
        "port": "8883",
        "tls": "4e3e159d8e243951",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "761c288df6a58e96",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "8883",
        "tls": "11da567a0e42b5ae",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "873502a2020d1559",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "b6e1278c5d544171",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "sunny",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "197fbcc39e6717c7",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cake",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "4e3e159d8e243951",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cookie",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "11da567a0e42b5ae",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "sunny",
        "verifyservercert": true,
        "alpnprotocol": ""
    }
]