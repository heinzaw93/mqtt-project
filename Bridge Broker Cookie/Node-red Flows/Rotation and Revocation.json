[
    {
        "id": "2ebddd033522bb02",
        "type": "tab",
        "label": "Rotation and Revocation",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "7ca35eec79660980",
        "type": "mqtt in",
        "z": "2ebddd033522bb02",
        "name": "Revoke MQTTS",
        "topic": "revoke/MQTTS/cookie",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 700,
        "y": 320,
        "wires": [
            [
                "06a872be55aa01c5"
            ]
        ]
    },
    {
        "id": "06a872be55aa01c5",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Prepare bootstrap to trust CA",
        "func": "const fs = global.get('fs');\nconst caUrl = msg.payload.ca_url;\nconst fp    = msg.payload.fingerprint;\nconst prov_pass = msg.payload.prov_pass;\nconst MQTTS_CA_Certificate =msg.payload.MQTTS_CA_Certificate;\nconst prov_pass_path = \"/etc/mosquitto/certs/provisioner_password\";\nconst MQTTScertFilePath = \"/etc/mosquitto/certs/MQTTS.pem\";\nfs.writeFileSync(prov_pass_path, prov_pass, 'utf8');\nfs.writeFileSync(MQTTScertFilePath, MQTTS_CA_Certificate, 'utf8');\n\nif (!caUrl || !fp) {\n  node.error('Missing ca_url or fingerprint in Payload');\n  return null;\n}\n\n// One single line, no line breaks:\nmsg.payload = `step ca bootstrap --ca-url \"${caUrl}\" --fingerprint \"${fp}\" --install --force`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 980,
        "y": 320,
        "wires": [
            [
                "51e6781435a29424"
            ]
        ]
    },
    {
        "id": "51e6781435a29424",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Trust CA",
        "x": 1240,
        "y": 320,
        "wires": [
            [
                "03b76dcb01d597c6"
            ],
            [],
            []
        ]
    },
    {
        "id": "03b76dcb01d597c6",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Prepare to create MQTTS key and certificate",
        "func": "\n\n// --- Step 1: File paths ---\nconst certPath = '/etc/mosquitto/certs/jonny.pem';\nconst keyPath = '/etc/mosquitto/certs/jonny-key.pem';\nconst provPassFile = '/etc/mosquitto/certs/provisioner_password';\n\n// --- Step 2: Prepare step-ca command for Exec node ---\nmsg.payload = `step ca certificate jonny \\\n${certPath} \\\n${keyPath} \\\n--san jonny \\\n--san 192.168.153.1 \\\n--provisioner \"Admin JWK\" \\\n--provisioner-password-file ${provPassFile} \\\n--force`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1510,
        "y": 320,
        "wires": [
            [
                "09b79fb715720c0f"
            ]
        ]
    },
    {
        "id": "09b79fb715720c0f",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create MQTTS key and cerificate",
        "x": 1640,
        "y": 220,
        "wires": [
            [
                "36a6b9ce5f4127ee"
            ],
            [],
            []
        ]
    },
    {
        "id": "36a6b9ce5f4127ee",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "sudo systemctl restart mosquitto-cert-renew.service | sudo systemctl kill -s HUP mosquitto",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Restart renew service",
        "x": 1940,
        "y": 300,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "d795d58ce91934f6",
        "type": "mqtt in",
        "z": "2ebddd033522bb02",
        "name": "Renew ECC keys",
        "topic": "renew/ECC/cookie",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 700,
        "y": 520,
        "wires": [
            [
                "dce57b31bf4a4d18"
            ]
        ]
    },
    {
        "id": "dce57b31bf4a4d18",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Match ID",
        "func": "// === Step 1: Get stored device_id from global ===\nconst storedDeviceId = global.get(\"deviceID\", \"file\");   // from global.set(..., 'file')\n\n// === Step 2: Get incoming device_id ===\nconst incomingDeviceId = msg.payload.device_id;\n\n// === Step 3: Compare ===\nif (storedDeviceId && incomingDeviceId && storedDeviceId === incomingDeviceId) {\n    // ✅ IDs match\n    const deviceName = msg.payload.device_name || \"unknown\";\n     flow.set('deviceName', deviceName);\n    const privateKeyPath = `/etc/mosquitto/certs/${deviceName}-private-key.pem`;\n\n    // Exec node needs plain string\n    msg.payload = `openssl ecparam -genkey -name prime256v1 -out ${privateKeyPath}`;\n\n    return msg;\n} else {\n    node.warn(`❌ Device ID mismatch! Stored=${storedDeviceId}, Incoming=${incomingDeviceId}`);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 520,
        "wires": [
            [
                "3d060939434db2a4"
            ]
        ]
    },
    {
        "id": "3d060939434db2a4",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Cookie private key creation",
        "x": 1220,
        "y": 480,
        "wires": [
            [
                "7d8f408c29e656af"
            ],
            [],
            []
        ]
    },
    {
        "id": "7d8f408c29e656af",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "openssl ec -in /etc/mosquitto/certs/jonny-private-key.pem -pubout -out /etc/mosquitto/certs/jonny-public-key.pem",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Jonny public key creation",
        "x": 1390,
        "y": 580,
        "wires": [
            [
                "0a3556864970b2b1"
            ],
            [],
            []
        ]
    },
    {
        "id": "c9981908078385b2",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Insert Data Into Keys Table",
        "x": 2000,
        "y": 400,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "f5fd772ac544c040",
        "type": "change",
        "z": "2ebddd033522bb02",
        "name": "Set MQTTS Payload to sync database",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1850,
        "y": 560,
        "wires": [
            [
                "1b31111b0a3c6e18"
            ]
        ]
    },
    {
        "id": "cc2b844377241292",
        "type": "mqtt out",
        "z": "2ebddd033522bb02",
        "name": "Sync Keys Table",
        "topic": "sync/data/keys_",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "921750ee5d721dc5",
        "x": 2260,
        "y": 480,
        "wires": []
    },
    {
        "id": "0a3556864970b2b1",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Read keys and prepare data for Keys Table",
        "func": "// --- Simple combined function ---\n// 1) Read files -> put in global\n// 2) Build SQL -> put string cmd into msg.payload\n\nconst fs = global.get('fs');\nif (!fs) { node.error(\"fs not found in global (set with global.set('fs', require('fs')) )\"); return null; }\n\nconst dbPath     = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey  = env.get(\"DB_PASSWORD\");\nif (!pragmaKey) { node.error(\"DB_PASSWORD env not set\"); return null; }\n\n// === Paths ===\nconst publicKeyPath  = \"/etc/mosquitto/certs/jonny-public-key.pem\";\nconst privateKeyPath = \"/etc/mosquitto/certs/jonny-private-key.pem\";\nconst secretKeyPath  = \"/etc/mosquitto/certs/jonny-registration-secret-key.bin\";\n\n// --- Step 1: Read PEMs and store to global ---\nlet publicKey, privateKey;\ntry {\n  publicKey  = fs.readFileSync(publicKeyPath, 'utf8').trim();\n  privateKey = fs.readFileSync(privateKeyPath, 'utf8').trim();\n} catch (e) {\n  node.error(\"Read PEM failed: \" + e.message);\n  return null;\n}\nglobal.set(\"public_key\",  publicKey,  \"file\");\nglobal.set(\"private_key\", privateKey, \"file\");\n\n// --- Step 2: Get deviceID (already set elsewhere) ---\nconst deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) { node.error(\"deviceID not found in global context\"); return null; }\n\n// --- Step 3: Read registration secret (binary) ---\nlet secretBuf;\ntry {\n  secretBuf = fs.readFileSync(secretKeyPath);  // raw binary\n} catch (e) {\n  node.error(\"Read registration secret failed: \" + e.message);\n  return null;\n}\nconst secretHex = secretBuf.toString('hex');\n\n// --- Step 4: Build SQL (escape single quotes in PEMs) ---\nconst esc = s => s.replace(/'/g, \"''\");\nconst sql = `\nPRAGMA key='${pragmaKey}';\nINSERT OR REPLACE INTO Keys (device_id, private_key, public_key, registration_key)\nVALUES ('${esc(deviceID)}', '${esc(privateKey)}', '${esc(publicKey)}', X'${secretHex}');\n`.trim();\n\nconst deviceName = flow.get('deviceName');\n// --- Step 5: Prepare exec command (must be a plain string) ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sql}\"`;\n\n// (Optional) also attach MQTT payload\nmsg.mqtt_payload = {\n    device_id: deviceID,\n    devicename:deviceName,\n    public_key: publicKey\n    // Optionally, use Base64 instead: secretKeyBuffer.toString('base64')\n};\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 480,
        "wires": [
            [
                "c9981908078385b2",
                "f5fd772ac544c040"
            ]
        ]
    },
    {
        "id": "67a2fddd51cc3957",
        "type": "inject",
        "z": "2ebddd033522bb02",
        "name": "Renew JWT",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "300",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 720,
        "y": 840,
        "wires": [
            [
                "2d0d50f6c2aaf36d"
            ]
        ]
    },
    {
        "id": "2d0d50f6c2aaf36d",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Prepare to Select JWT",
        "func": "const dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 1: Get deviceID from global context ---\nlet deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) {\n    node.error(\"❌ deviceID not found in global context.\");\n    return null;\n}\n\n// --- Step 2: Escape single quotes ---\ndeviceID = deviceID.replace(/'/g, \"''\");\n\n// --- Step 3: Build SELECT query (only jwt_token) ---\nconst sqlSelect = `\nPRAGMA key = '${pragmaKey}';\nSELECT jwt_token \nFROM DeviceProfile \nWHERE device_id = '${deviceID}';\n`;\n\n// --- Step 4: Send command to exec node ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlSelect.trim()}\"`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 940,
        "y": 780,
        "wires": [
            [
                "4ceb2e6c16fbb544"
            ]
        ]
    },
    {
        "id": "4ceb2e6c16fbb544",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Select JWT",
        "x": 1150,
        "y": 780,
        "wires": [
            [
                "40f1088daae62afe"
            ],
            [],
            []
        ]
    },
    {
        "id": "40f1088daae62afe",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Validate JWT expire",
        "func": "// Input: msg.payload = JWT string (may include surrounding quotes from sqlcipher)\n// Output (when ttl < 60): msg.payload = { device_id, jwt }\n\nconst deviceID = global.get(\"deviceID\", \"file\");\nif (!deviceID) { node.error(\"deviceID not found in global context\"); return null; }\n\n// 1) Get token string\nlet token = (msg.payload ?? \"\").toString().trim();\n// strip surrounding quotes if present\nif (token.startsWith('\"') && token.endsWith('\"')) token = token.slice(1, -1);\n\n// basic check\nif (!token || !token.includes(\".\")) { node.error(\"Invalid JWT\"); return null; }\n\n// 2) Decode base64url payload\nfunction b64urlToJson(b64u) {\n  const b64 = b64u.replace(/-/g, '+').replace(/_/g, '/');\n  const pad = (4 - (b64.length % 4)) % 4;\n  return JSON.parse(Buffer.from(b64 + \"=\".repeat(pad), \"base64\").toString(\"utf8\"));\n}\n\ntry {\n  const parts = token.split(\".\");\n  if (parts.length < 2) { node.error(\"Malformed JWT\"); return null; }\n  const claims = b64urlToJson(parts[1]);\n\n  const now = Math.floor(Date.now() / 1000);\n  const iat = Number(claims.iat || 0);\n  const exp = Number(claims.exp || 0);\n  const ttl = Math.max(0, exp - now);\n\n  if (!iat || !exp) { node.error(\"JWT missing iat/exp\"); return null; }\n\n  if (ttl < 60) {\n    // need refresh -> pass device_id and token forward\n    msg.payload = { device_id: deviceID, jwt: token };\n    return msg;\n  } else {\n    node.warn(`jwt is still valid (ttl_seconds=${ttl})`);\n    return null; // stop here\n  }\n} catch (e) {\n  node.error(\"Failed to decode JWT: \" + e.message);\n  return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 780,
        "wires": [
            [
                "c3bc3355c9dcd29a"
            ]
        ]
    },
    {
        "id": "c3bc3355c9dcd29a",
        "type": "mqtt out",
        "z": "2ebddd033522bb02",
        "name": "Request to renew JWT",
        "topic": "renew/jwt/cookie",
        "qos": "",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "72399054283f9843",
        "x": 1720,
        "y": 780,
        "wires": []
    },
    {
        "id": "4f7e919df2c972aa",
        "type": "mqtt in",
        "z": "2ebddd033522bb02",
        "name": "Respond new JWT",
        "topic": "respond/jwt/cookie",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "761c288df6a58e96",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 770,
        "y": 1020,
        "wires": [
            [
                "f8c285337e07be0c"
            ]
        ]
    },
    {
        "id": "3013fd010e686818",
        "type": "exec",
        "z": "2ebddd033522bb02",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Update JWT",
        "x": 1490,
        "y": 1020,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "39d0ef6dc89b7035",
        "type": "mqtt in",
        "z": "2ebddd033522bb02",
        "name": "RenewJWT",
        "topic": "renew/JWT/cookie",
        "qos": "2",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 710,
        "y": 720,
        "wires": [
            [
                "2d0d50f6c2aaf36d"
            ]
        ]
    },
    {
        "id": "2d12ec48041f9600",
        "type": "comment",
        "z": "2ebddd033522bb02",
        "name": "MQTT Bridge Broker (Cookie)",
        "info": "",
        "x": 760,
        "y": 140,
        "wires": []
    },
    {
        "id": "8f4e4067cd2158bb",
        "type": "comment",
        "z": "2ebddd033522bb02",
        "name": "Revoke MQTTS Certs and Key",
        "info": "",
        "x": 770,
        "y": 240,
        "wires": []
    },
    {
        "id": "dd76a64a2e723499",
        "type": "comment",
        "z": "2ebddd033522bb02",
        "name": "Renew Keys",
        "info": "",
        "x": 690,
        "y": 460,
        "wires": []
    },
    {
        "id": "8d972e3e48cfee3c",
        "type": "comment",
        "z": "2ebddd033522bb02",
        "name": "Renew JWT",
        "info": "",
        "x": 710,
        "y": 660,
        "wires": []
    },
    {
        "id": "0d2c4e80093177e9",
        "type": "comment",
        "z": "2ebddd033522bb02",
        "name": "Recieved new JWT",
        "info": "",
        "x": 750,
        "y": 960,
        "wires": []
    },
    {
        "id": "1b31111b0a3c6e18",
        "type": "delay",
        "z": "2ebddd033522bb02",
        "name": "",
        "pauseType": "delay",
        "timeout": "10",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "allowrate": false,
        "outputs": 1,
        "x": 2080,
        "y": 460,
        "wires": [
            [
                "cc2b844377241292"
            ]
        ]
    },
    {
        "id": "f8c285337e07be0c",
        "type": "function",
        "z": "2ebddd033522bb02",
        "name": "Validate JWT and prepare to update database",
        "func": "const fs        = global.get('fs');\nconst jwt       = global.get('jwt');\nconst crypto    = global.get('crypto');\n\nconst dbPath    = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 1: Get incoming payload ---\nconst payload          = msg.payload || {};\nconst incomingDeviceId = payload.device_id;\nconst newJwt           = payload.jwt;\nconst signatureB64     = payload.jwt_sig_b64;    // expecting signature field\n\n// --- Step 2: Get stored deviceId ---\nlet storedDeviceId = global.get(\"deviceID\", \"file\");\nif (!storedDeviceId) {\n    node.error(\"❌ deviceID not found in global context\");\n    return null;\n}\n\n// --- Step 3: Compare IDs ---\nif (incomingDeviceId !== storedDeviceId) {\n    node.warn(`❌ Device ID mismatch. Incoming=${incomingDeviceId}, Stored=${storedDeviceId}`);\n    return null;\n}\n\n// --- Step 4: Verify signature over (device_id | jwt) ---\nif (!signatureB64) {\n    node.warn(\"❌ Missing jwt_sig_b64 in payload\");\n    return null;\n}\n\nlet sunnyPub;\ntry {\n    sunnyPub = fs.readFileSync(\"/etc/mosquitto/certs/sunny-public-key.pem\", \"utf8\");\n} catch (e) {\n    node.error(\"❌ Unable to read sunny-public-key.pem: \" + e.message);\n    return null;\n}\n\nconst verify = crypto.createVerify(\"sha256\");\nverify.update(`${incomingDeviceId}|${newJwt}`);\nverify.end();\n\nlet sigOK;\ntry {\n    sigOK = verify.verify(sunnyPub, signatureB64, \"base64\");\n} catch (e) {\n    node.warn(\"❌ Signature verification error: \" + e.message);\n    return null;\n}\n\nif (!sigOK) {\n    node.warn(\"❌ Signature invalid for device_id and jwt.\");\n    return null;\n}\nnode.warn(`✅ Signature verified new JWT come from Sunny for device_id=${incomingDeviceId}`);\n\n// --- Step 5: Escape values for SQL ---\nconst esc = s => (s ?? \"\").toString().replace(/'/g, \"''\");\nconst sqlUpdate = `\nPRAGMA key='${pragmaKey}';\nUPDATE DeviceProfile\nSET jwt_token='${esc(newJwt)}'\nWHERE device_id='${esc(storedDeviceId)}';\n`.trim();\n\n// --- Step 6: Prepare exec payload ---\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlUpdate}\"`;\n\nnode.warn(`✅ JWT updated for device_id: ${storedDeviceId}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1120,
        "y": 1000,
        "wires": [
            [
                "3013fd010e686818"
            ]
        ]
    },
    {
        "id": "9cddc1bd885980b7",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.153.1",
        "port": "8883",
        "tls": "4e3e159d8e243951",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "921750ee5d721dc5",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.153.1",
        "port": 1883,
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "72399054283f9843",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "8883",
        "tls": "b6e1278c5d544171",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "761c288df6a58e96",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "8883",
        "tls": "11da567a0e42b5ae",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "4e3e159d8e243951",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cookie",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "b6e1278c5d544171",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "sunny",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "11da567a0e42b5ae",
        "type": "tls-config",
        "name": "",
        "cert": "/etc/mosquitto/certs/cookie.pem",
        "key": "/etc/mosquitto/certs/cookie-key.pem",
        "ca": "/etc/mosquitto/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "sunny",
        "verifyservercert": true,
        "alpnprotocol": ""
    }
]