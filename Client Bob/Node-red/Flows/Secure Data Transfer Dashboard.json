[
    {
        "id": "a65d1393aff03429",
        "type": "tab",
        "label": "Secure Data Transfer Dashboard",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "9773aea33d970de6",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "termux-wifi-connectioninfo | grep ip",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Check Network",
        "x": 880,
        "y": 440,
        "wires": [
            [
                "bab99e3cd2913679"
            ],
            [],
            []
        ]
    },
    {
        "id": "51591980c94b8524",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Register topic to send data",
        "info": "",
        "x": 150,
        "y": 220,
        "wires": []
    },
    {
        "id": "bab99e3cd2913679",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Prepere to create topic registration secret key",
        "func": "const crypto = global.get('crypto');\nconst fs = global.get('fs');\n\n// === 1) Get topic name from flow ===\nconst topic_name = flow.get(\"topic_name\");\nnode.warn(\"üìå Topic name: \" + topic_name);\n\n// === 2. Get Wi-Fi SSID from msg.payload ===\nlet raw = msg.payload.trim();\n\n// Try to extract IP using regex\nlet ipMatch = raw.match(/\"ip\"\\s*:\\s*\"(\\d+\\.\\d+\\.\\d+\\.\\d+)\"/);\nif (!ipMatch) {\n  node.status({ fill: \"red\", shape: \"ring\", text: \"IP not found\" });\n  return null;\n}\n\nlet ip = ipMatch[1];  // Extracted IP string\nlet ssid = \"\";\n\n// === 2. Map IP subnet to SSID ===\nif (/^192\\.168\\.151\\./.test(ip)) {\n  ssid = \"Network-01\";\n} else if (/^192\\.168\\.152\\./.test(ip)) {\n  ssid = \"Network-02\";\n} else if (/^192\\.168\\.153\\./.test(ip)) {\n  ssid = \"Network-A\";\n} else if (/^192\\.168\\.154\\./.test(ip)) {\n  ssid = \"Network-B\";\n} else {\n  ssid = \"Unknown\";\n}\n//node.warn(ssid);\nflow.set('wifi_ssid', ssid);\n// === 3) Get deviceID from global (with retries) ===\nlet deviceID;\nlet attempts = 0;\nwhile (!deviceID && attempts < 5) {\n  deviceID = global.get(\"deviceID\", \"file\");\n  if (!deviceID) {\n    node.warn(\"Retrying retrieval of deviceID...\");\n    attempts++;\n    const waitUntil = Date.now() + 200; // busy-wait 200ms\n    while (Date.now() < waitUntil);\n  }\n}\nif (!deviceID) {\n  node.error(\"‚ùå DeviceID not found in global context!\");\n  return null;\n}\n\n// === 4) Load Bob‚Äôs private key from global ===\nconst privateKeyPEM = global.get(\"private_key\", \"file\");\nif (!privateKeyPEM) {\n  node.error(\"‚ùå Bob's private key not found in global context!\");\n  return null;\n}\n\n// === 5) Create signature over `${deviceID}|${topic_name}` ===\nconst dataToSign = `${deviceID}|${topic_name}`;\nconst signer = crypto.createSign('sha256');\nsigner.update(dataToSign);\nsigner.end();\nconst signature = signer.sign(privateKeyPEM, 'base64');\n\n// Save signature and ssid to flow for later use\nflow.set(\"signature\", signature);\n\n\n// === 6) Prepare ECDH derive cdata/dommand ===\nconst certDir = \"/data/data/com.termux/files/home/.node-red/certs\";\nconst bobPriv = `${certDir}/bob-private-key.pem`;\nconst sunnyPub = `${certDir}/sunny-public-key.pem`;\nconst outSecret = `${certDir}/bob-topic-registration-secret-key.bin`;\n\nif (fs) {\n  if (!fs.existsSync(bobPriv)) node.warn(`‚ö†Ô∏è Missing ${bobPriv}`);\n  if (!fs.existsSync(sunnyPub)) node.warn(`‚ö†Ô∏è Missing ${sunnyPub}`);\n}\n\n\n\n// === 7) Set the command as msg.payload for Exec node ===\nmsg.payload = `openssl pkeyutl -derive -inkey ${bobPriv} -peerkey ${sunnyPub} -out ${outSecret}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1190,
        "y": 360,
        "wires": [
            [
                "49920c9ed5ce2c18"
            ]
        ]
    },
    {
        "id": "574abb5c6c41be9e",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send register via Cookie",
        "topic": "topic/register/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fcc9581fb1cd01fb",
        "x": 2510,
        "y": 320,
        "wires": []
    },
    {
        "id": "65676e55ba6940d6",
        "type": "switch",
        "z": "a65d1393aff03429",
        "name": "Send MQTTS payload according to SSID connected",
        "property": "payload.wifi_ssid",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Network-01",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-02",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-A",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-B",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1980,
        "y": 320,
        "wires": [
            [
                "46b89d3b163e0cf6"
            ],
            [
                "46b89d3b163e0cf6"
            ],
            [
                "574abb5c6c41be9e"
            ],
            [
                "04c974e3d0489b09"
            ]
        ]
    },
    {
        "id": "49920c9ed5ce2c18",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create topic registration secret key",
        "x": 1540,
        "y": 280,
        "wires": [
            [
                "85da3619eb137d00"
            ],
            [],
            []
        ]
    },
    {
        "id": "85da3619eb137d00",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Prepare to register topic (encrypt + sign) + baseline attach",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// Pull ctx from msg or flow (Plan A robustness)\nconst ctx = msg.kms_ctx || flow.get('current_run_ctx') || {};\n\n// topic from ctx or flow\nconst topic_name = String(ctx.topic_name || flow.get('topic_name') || '').trim();\nif (!topic_name) { node.error('Missing topic_name'); return null; }\n\nconst wifi_ssid = String(flow.get('wifi_ssid') || '').trim();\nif (!wifi_ssid) { node.error('Missing wifi_ssid'); return null; }\n\nconst deviceID = global.get('deviceID','file');\nif (!deviceID) { node.error('Missing deviceID'); return null; }\n\n// Derive AES key from ECDH secret\nconst secretPath = '/data/data/com.termux/files/home/.node-red/certs/bob-topic-registration-secret-key.bin';\nif (!fs.existsSync(secretPath)) { node.error(`Missing ${secretPath}`); return null; }\nconst secretBin = fs.readFileSync(secretPath);\nconst aesKey = crypto.createHash('sha256').update(secretBin).digest();\n\n// Sign `${deviceID}|${topic_name}` using Alice private key\nconst privateKeyPEM = global.get('private_key','file');\nif (!privateKeyPEM) { node.error('Alice private key missing in global(file)'); return null; }\nconst signer = crypto.createSign('sha256');\nsigner.update(`${deviceID}|${topic_name}`);\nsigner.end();\nconst signature = signer.sign(privateKeyPEM, 'base64');\n\n// Encrypt registration payload\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', aesKey, iv);\nconst body = JSON.stringify({ deviceID, topic_name });\nlet encrypted = cipher.update(body,'utf8','hex');\nencrypted += cipher.final('hex');\n\n// Build message (with meta + seq/total)\nmsg.payload = {\n  encryptedData: encrypted,\n  iv: iv.toString('hex'),\n  signature,\n  device_id: deviceID,\n  wifi_ssid,\n  type: 'data',\n  t_pub: ctx.t_pub,\n  run_id: ctx.run_id,\n  run_tag: ctx.run_tag,\n  mode: ctx.mode,\n  path_class: ctx.path_class,\n  mqtt_version: ctx.mqtt_version,\n  qos: ctx.qos,\n  rate_mps: ctx.rate_mps,\n  msg_count: ctx.msg_count,\n  duration: ctx.duration,\n  seq: Number(ctx.seq || 0),\n  total: Number(ctx.total || 0)\n};\n\nif (msg.kms_control) { msg.payload.kms_control = msg.kms_control; }\n\nconst runKey = String(ctx.run_id || ctx.run_tag || 'default');\nconst qKey = `kms_q_${runKey}`;\nlet q = flow.get(qKey) || [];\nif (Number.isFinite(ctx.t_pub)) { q.push(ctx.t_pub); flow.set(qKey, q); }\n\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1670,
        "y": 400,
        "wires": [
            [
                "65676e55ba6940d6"
            ]
        ]
    },
    {
        "id": "5443d710323f9fba",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "Start Run (KMS, QoS0, 5 msg/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_rate5",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "secure",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "0",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "5",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "120",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 190,
        "y": 420,
        "wires": [
            [
                "d3d8f124c548cb58"
            ]
        ]
    },
    {
        "id": "e8505724a8fe15f1",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "Start Run (KMS, QoS0, 10 msg/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_rate10",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "secure",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "0",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "10",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "120",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 180,
        "y": 480,
        "wires": [
            [
                "d3d8f124c548cb58"
            ]
        ]
    },
    {
        "id": "82c130dfe2433758",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "Start Run (KMS, QoS0, 20 msg/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_rate20",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "secure",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "0",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "20",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "120",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 180,
        "y": 540,
        "wires": [
            []
        ]
    },
    {
        "id": "9b16b957df24c963",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "E2E Start Run (100 msgs @1/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_100_rate1",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "e2e",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "1",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "1",
                "vt": "num"
            },
            {
                "p": "msg_count",
                "v": "100",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "100",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 210,
        "y": 640,
        "wires": [
            [
                "d3d8f124c548cb58"
            ]
        ]
    },
    {
        "id": "725fe04380ade7c5",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "E2E Start Run (200 msgs @1/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_200_rate1",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "e2e",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "0",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "1",
                "vt": "num"
            },
            {
                "p": "msg_count",
                "v": "200",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "200",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 170,
        "y": 700,
        "wires": [
            [
                "d3d8f124c548cb58"
            ]
        ]
    },
    {
        "id": "2894c3116d20d1af",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "E2E Start Run (300 msgs @1/s)",
        "props": [
            {
                "p": "run_id",
                "v": "",
                "vt": "date"
            },
            {
                "p": "run_tag",
                "v": "secure_single_300_rate1",
                "vt": "str"
            },
            {
                "p": "mode",
                "v": "e2e",
                "vt": "str"
            },
            {
                "p": "path_class",
                "v": "single_broker",
                "vt": "str"
            },
            {
                "p": "mqtt_version",
                "v": "3.1.1",
                "vt": "str"
            },
            {
                "p": "qos",
                "v": "0",
                "vt": "num"
            },
            {
                "p": "rate_mps",
                "v": "1",
                "vt": "num"
            },
            {
                "p": "msg_count",
                "v": "300",
                "vt": "num"
            },
            {
                "p": "duration",
                "v": "300",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 170,
        "y": 780,
        "wires": [
            [
                "d3d8f124c548cb58"
            ]
        ]
    },
    {
        "id": "68fcba64c107a86a",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": true,
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "oldrc": false,
        "name": "Exec: start monitor (mosquitto)",
        "x": 1410,
        "y": 480,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "490dc95edd502102",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": true,
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "oldrc": false,
        "name": "Exec: start monitor (node-red)",
        "x": 1250,
        "y": 580,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "32936eb3625e9a15",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "termux-camera-photo -c 0 ~/.node-red/test.png",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Take Picture",
        "x": 790,
        "y": 1020,
        "wires": [
            [
                "2c10f4efc0a84a28"
            ],
            [],
            []
        ]
    },
    {
        "id": "37f4a0130dcde89a",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Publish picture via Cookie",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fcc9581fb1cd01fb",
        "x": 1830,
        "y": 860,
        "wires": []
    },
    {
        "id": "27b3b845874766ab",
        "type": "switch",
        "z": "a65d1393aff03429",
        "name": "Send MQTTS payload according to SSID connected",
        "property": "payload.wifi_ssid",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Network-01",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-02",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-A",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-B",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1460,
        "y": 860,
        "wires": [
            [
                "70ec185ab66d1fa0"
            ],
            [
                "70ec185ab66d1fa0"
            ],
            [
                "37f4a0130dcde89a"
            ],
            [
                "14dc913507ae4350"
            ]
        ]
    },
    {
        "id": "e1370b5c1a2c1447",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Receive encrypted data  + prep key-req",
        "func": "// Function ‚Äî Receive encrypted data, cache it, capture KMS meta,\n// prepare key-req (ECDH secret + sender public-key query), and start monitors\n\nconst fs = global.get(\"fs\");\nconst crypto = global.get(\"crypto\");\n\n// === 1) Extract inbound payload ===\nconst topic_name = String(msg.topic || \"\");\nconst p = msg.payload || {};\n\nconst iv_b64       = String(p.iv_b64 || \"\").trim();\nconst ct_b64       = String(p.ct_b64 || \"\").trim();\nconst filename     = String(p.filename || \"\").trim();\nconst ct_nt_b64    = String(p.msg_ct_b64 || \"\").trim();\nconst senderDeviceID = String(p.sender_device_id || \"\").trim();\n\n// --- 1a) Quick MITM filter: ignore original packets in MITM run ---\n// We look at mode + run_tag directly from payload / kms_meta.\n// If run_tag == \"MITM\" and mode != \"cookie_sig_shift_3\", this is Alice's\n// original message; we do NOT want it to overwrite flow state.\nconst kmQuick = p.kms_meta || {};\nconst rawMode   = (p.mode !== undefined) ? p.mode : kmQuick.mode;\nconst rawRunTag = String(p.run_tag || kmQuick.run_tag || \"\");\n\nif (rawRunTag === \"MITM\" && rawMode !== \"cookie_sig_shift_3\") {\n  // Ignore this message completely for key-request/decrypt pipeline\n  // (only Cookie's tampered messages should be processed in MITM test)\n  return [null, null, null];\n}\n\n// Cache cipher + file info for later decryption\nflow.set(\"topic_name\", topic_name);\nflow.set(\"iv_b64\", iv_b64);\nflow.set(\"ct_b64\", ct_b64);\nflow.set(\"filename\", filename);\nflow.set(\"ct_nt_b64\", ct_nt_b64);\n\n// cache sender signature for final verification\nconst senderSigB64 =\n  String(p.sender_signature_b64 || p.signature_b64 || \"\").trim();\n\nif (senderSigB64) {\n  flow.set(\"sender_signature_b64\", senderSigB64);\n  // node.warn(\"‚úî Sender signature saved to flow (sender_signature_b64)\");\n} else {\n  node.warn(\"‚ö† No sender signature found in incoming payload.\");\n}\n\n// --- 2) Capture KMS / E2E meta (from top-level or nested kms_meta) ---\nconst km = p.kms_meta || {};\nconst meta = {\n  run_id:       String(p.run_id || km.run_id || \"\"),\n  run_tag:      String(p.run_tag || km.run_tag || \"\"),\n  mode:         (p.mode !== undefined) ? p.mode : km.mode,\n  path_class:   (p.path_class !== undefined)   ? p.path_class   : km.path_class,\n  mqtt_version: (p.mqtt_version !== undefined) ? p.mqtt_version : km.mqtt_version,\n  qos:          (p.qos !== undefined)          ? p.qos          : km.qos,\n  rate_mps:     (p.rate_mps !== undefined)     ? p.rate_mps     : km.rate_mps,\n  msg_count:    Number(p.msg_count ?? km.msg_count ?? 0),\n  duration:     Number(p.duration ?? km.duration ?? 0),\n  t_pub:        Number(p.t_pub ?? km.t_pub ?? 0),\n\n  // track seq / total explicitly\n  seq:   Number(p.seq ?? km.seq ?? 0),\n  total: Number(p.total ?? km.total ?? 0),\n\n  kms_control: p.kms_control || km.kms_control || \"\"\n};\nflow.set(\"kms_meta_bob\", meta);\n\n// --- mark run \"done\" if control OR high coverage by seq/total ---\nconst runKey = String(meta.run_id || meta.run_tag || \"default\");\n\n// expected by seq (from Alice‚Äôs view)\nconst expectedBySeq =\n  Number.isFinite(meta.total) && meta.total > 0 ? meta.total : 0;\n\nconst coverage = expectedBySeq > 0 && meta.seq > 0\n  ? meta.seq / expectedBySeq\n  : 0;\n\n// Threshold: if we saw ‚â•95% of expected seqs, we still summarise\nconst COVERAGE_THRESHOLD = 0.95;\n\nif (\n  meta.kms_control === \"done\" ||\n  (coverage >= COVERAGE_THRESHOLD && expectedBySeq > 0)\n) {\n  flow.set(`secure_e2e_done_${runKey}`, true);\n}\n\n// === 3) Build signature `${deviceID}|${topic_name}` for topic-key request ===\nconst deviceID = global.get(\"deviceID\", \"file\");\nconst privateKeyPEM = global.get(\"private_key\", \"file\");\nif (!deviceID || !privateKeyPEM) {\n  node.error(\"‚ùå Missing deviceID or private_key in global(file) context.\");\n  return [null, null, null];\n}\n\nconst signer = crypto.createSign(\"sha256\");\nsigner.update(`${deviceID}|${topic_name}`);\nsigner.end();\nconst signature = signer.sign(privateKeyPEM, \"base64\");\nflow.set(\"signature\", signature);\n\n// === 4) Prepare commands for Exec node (ECDH derive + SELECT public_key) ===\nconst execMsgs = [];\n\n// 4a) ECDH derive secret for topic-key-request\nconst certDir  = \"/data/data/com.termux/files/home/.node-red/certs\";\nconst bobPriv  = `${certDir}/bob-private-key.pem`;\nconst sunnyPub = `${certDir}/sunny-public-key.pem`;\nconst outSecret = `${certDir}/bob-topic-key-request-secret-key.bin`;\n\nif (fs) {\n  if (!fs.existsSync(bobPriv))  node.warn(`‚ö†Ô∏è Missing ${bobPriv}`);\n  if (!fs.existsSync(sunnyPub)) node.warn(`‚ö†Ô∏è Missing ${sunnyPub}`);\n}\n\nconst opensslCmd =\n  `openssl pkeyutl -derive -inkey ${bobPriv} -peerkey ${sunnyPub} -out ${outSecret}`;\nexecMsgs.push({ payload: opensslCmd });\n\n// 4b) SQLCipher query: get sender's public key from Keys table (with WAL)\nif (!senderDeviceID) {\n  node.warn(\"‚ö†Ô∏è sender_device_id not present in payload; skipping public_key SELECT.\");\n} else {\n  const dbPath    = \"/data/data/com.termux/files/home/.node-red/update_database.db\";\n  const pragmaKey = env.get(\"DB_PASSWORD\");\n  const safeDevID = senderDeviceID.replace(/'/g, \"''\");\n\n  const sqlQuery = `\nPRAGMA key='${pragmaKey}';\nPRAGMA journal_mode=WAL;\nSELECT public_key FROM Keys WHERE device_id = '${safeDevID}';\n`.trim();\n\n  // Use your usual here-string pattern\n  const sqlCmd = `echo \"${sqlQuery.trim()}\" | sqlcipher ${dbPath}`;\n  execMsgs.push({ payload: sqlCmd });\n}\n\n// === 5) Start monitors (mosquitto + node-red) once per run, with duration ===\nlet startMon1 = null;\nlet startMon2 = null;\n\nconst monKey = `bob_mon_${runKey}`;\n\nif (!flow.get(monKey)) {\n  const scriptPath   = \"/data/data/com.termux/files/home/.node-red/perf_results/monitor_sys_stats.sh\";\n  const qosArg       = String(meta.qos ?? \"\");\n  const mqttArg      = String(meta.mqtt_version ?? \"\");\n  const runTag       = String(meta.run_tag || \"run\");\n  const dur          = Number.isFinite(meta.duration) && meta.duration > 0 ? meta.duration : 120;\n  const durationArg  = String(dur);\n\n  startMon1 = {\n    payload: `${scriptPath} ${runTag} mosquitto ${qosArg} ${mqttArg} ${durationArg}`\n  };\n  startMon2 = {\n    payload: `${scriptPath} ${runTag} node-red ${qosArg} ${mqttArg} ${durationArg}`\n  };\n\n  flow.set(monKey, true);\n  node.status({ fill: \"blue\", shape: \"dot\",\n                text: `monitors started (${runTag}, ${durationArg}s)` });\n}\n\n// Output1 -> Exec node (two commands), Output2 -> start mosquitto monitor,\n// Output3 -> start node-red monitor\nreturn [execMsgs, startMon1, startMon2];\n",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 1520,
        "wires": [
            [
                "65ee69f99f83b1ab"
            ],
            [
                "b2c75fbffa9a4a2e"
            ],
            [
                "703376c722a0e69d"
            ]
        ]
    },
    {
        "id": "65ee69f99f83b1ab",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Create topic key request secret key",
        "x": 680,
        "y": 1420,
        "wires": [
            [
                "357b166316931983"
            ],
            [],
            []
        ]
    },
    {
        "id": "b2c75fbffa9a4a2e",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": true,
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Start monitor (mosquitto)",
        "x": 790,
        "y": 1540,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "703376c722a0e69d",
        "type": "exec",
        "z": "a65d1393aff03429",
        "command": "",
        "addpay": true,
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Start monitor (node-red)",
        "x": 690,
        "y": 1660,
        "wires": [
            [],
            [],
            []
        ]
    },
    {
        "id": "357b166316931983",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Prepare to request topic key (encrypt + sign)",
        "func": "// Function ‚Äî Build encrypted Topic-Key-Request (minimal payload to Sunny)\n// + parse Exec stdout to cache sender's public key PEM in flow\n\nconst fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// === 0) Parse Exec stdout: ONLY continue when this chunk has a PEM ===\n// Exec stdout can come in multiple chunks: \"\", \"ok\", \"wal\", \"ok\\nwal\\n-----BEGIN PUBLIC KEY-----...\".\nlet senderPubKeyPEM;\n\ntry {\n    const s = String(msg.payload || \"\");\n    const pemMatch = s.match(/-----BEGIN PUBLIC KEY-----[\\s\\S]+?-----END PUBLIC KEY-----/);\n\n    if (!pemMatch) {\n        // This is just an empty string or status text (\"ok\", \"wal\", etc.) ‚Üí ignore.\n        // Do NOT build/send a topic-key-request for this chunk.\n        return null;\n    }\n\n    senderPubKeyPEM = pemMatch[0].trim();\n    flow.set(\"sender_public_key_pem\", senderPubKeyPEM);\n    // node.warn(\"‚úÖ Sender public key PEM extracted and saved to flow (sender_public_key_pem).\");\n} catch (e) {\n    node.warn(\"‚ö†Ô∏è Failed to parse public key from Exec output: \" + e.message);\n    return null;\n}\n\n// === 1) Context ===\nconst topic_name = flow.get('topic_name');\nconst deviceID   = global.get('deviceID', 'file');\nconst signature  = flow.get('signature');\nconst wifi_ssid  = flow.get('wifi_ssid');   // set elsewhere in Bob's flow\n\nif (!topic_name) { node.error('‚ùå Missing topic_name in flow'); return null; }\nif (!deviceID)   { node.error('‚ùå Missing deviceID in global(file) context'); return null; }\nif (!signature)  { node.error('‚ùå Missing signature in flow'); return null; }\n\n// === 2) Load derived topic-key-request secret ===\nconst secretPath = '/data/data/com.termux/files/home/.node-red/certs/bob-topic-key-request-secret-key.bin';\nif (!fs.existsSync(secretPath)) {\n  node.error(`‚ùå Secret key not found: ${secretPath}`);\n  return null;\n}\nconst secretBin = fs.readFileSync(secretPath);\nconst aesKey = crypto.createHash('sha256').update(secretBin).digest();\n\n// === 3) Encrypt payload { deviceID, topic_name } ===\nconst iv = crypto.randomBytes(16);\nconst plaintext = JSON.stringify({ deviceID, topic_name });\nconst cipher = crypto.createCipheriv('aes-256-cbc', aesKey, iv);\nlet encrypted = cipher.update(plaintext, 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\n// Optional: store local timestamp for key-request latency (not sent to Sunny)\nflow.set('t_keyreq_publish', Date.now());\n\n// === 4) Minimal outbound payload for Sunny ===\nmsg.payload = {\n  encryptedData: encrypted,\n  iv: iv.toString('hex'),\n  signature: signature,\n  device_id: deviceID,\n  wifi_ssid: wifi_ssid\n};\n\n//node.warn(`Encrypt / Sign Topic-Key-Request ready for topic \"${topic_name}\" from Bob`);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1070,
        "y": 1460,
        "wires": [
            [
                "4553e080649ab1e3"
            ]
        ]
    },
    {
        "id": "59c748fb3812b35d",
        "type": "file",
        "z": "a65d1393aff03429",
        "name": "append bob_perf_secure.csv",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": true,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1060,
        "y": 1860,
        "wires": [
            []
        ]
    },
    {
        "id": "a22859cbb92e257d",
        "type": "file",
        "z": "a65d1393aff03429",
        "name": "append summary_latency_secure.csv",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": true,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1090,
        "y": 1940,
        "wires": [
            []
        ]
    },
    {
        "id": "3eb72e4cfc3d7914",
        "type": "file",
        "z": "a65d1393aff03429",
        "name": "",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 1000,
        "y": 1760,
        "wires": [
            []
        ]
    },
    {
        "id": "cdd576c3a55dbdd1",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send topic key request  via Cake",
        "topic": "topic/key_req/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d7e23934af9f8ad1",
        "x": 1610,
        "y": 1720,
        "wires": []
    },
    {
        "id": "d3d8f124c548cb58",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Rate Scheduler + Timestamp + Script Trigger (dual service)",
        "func": "const mode   = String(msg.mode || 'secure');\nconst baseRate = Number(msg.rate_mps || 0);\nconst runId  = String(msg.run_id || Date.now());\nconst runTag = String(msg.run_tag || 'run');\nconst qosArg  = String(msg.qos ?? '');\nconst mqttArg = String(msg.mqtt_version ?? '');\n\nconst msgCountIn   = Number(msg.msg_count || 0);\nconst durationIn   = Number(msg.duration || 0);\n\nlet rate = baseRate;\nlet testSeconds = 120;\nlet total;\n\n// --------- Choose semantics: KMS (rate-based) vs E2E (fixed #msgs) ----------\nif (mode === 'e2e' && msgCountIn > 0) {\n  // E2E: total messages = msg_count, duration = durationIn or msgCountIn\n  total = msgCountIn;\n  if (durationIn > 0) {\n    testSeconds = durationIn;\n  } else {\n    // default: 1 msg per second\n    testSeconds = msgCountIn;\n  }\n  if (!Number.isFinite(rate) || rate <= 0) {\n    rate = msgCountIn / testSeconds;\n  }\n} else {\n  // KMS: fixed 120-second window, total = rate * 120\n  testSeconds = 120;\n  total = Math.max(0, Math.floor(baseRate * testSeconds));\n  rate = baseRate;\n}\n\nconst every = rate > 0 ? Math.max(1, Math.floor(1000 / rate)) : 1000;\n\n// --------- Store run context (also sent inside msgs to Sunny/Bob) ----------\nconst runCtx = {\n  run_id: runId,\n  run_tag: runTag,\n  mode: msg.mode,\n  path_class: msg.path_class,\n  mqtt_version: msg.mqtt_version,\n  qos: msg.qos,\n  rate_mps: rate,\n  msg_count: total,\n  duration: testSeconds          // <-- this is the duration we‚Äôll pass to scripts\n};\nflow.set('current_run_ctx', runCtx);\n\n// --------- Topic list / rotation ----------\nconst list = (flow.get('registeredTopics') || []).map(s => String(s)).filter(Boolean);\nif (!list.length && flow.get('topic_name')) list.push(flow.get('topic_name'));\nif (!list.length) { node.error('No topics in cache. Load topics.csv or pick one.'); return; }\n\nconst idxKey = `kms_topic_idx_${runId}`; flow.set(idxKey, 0);\nconst seqKey = `kms_seq_${runId}`;       flow.set(seqKey, 0);\n\n// --------- Start monitor scripts on Sunny (now with duration arg) ----------\nconst durationArg = testSeconds.toString();   // 120s for KMS, N seconds for E2E\n\nconst cmd1 = `/data/data/com.termux/files/home/.node-red/perf_results/monitor_sys_stats.sh ${runTag} mosquitto ${qosArg} ${mqttArg} ${durationArg}`;\nconst cmd2 = `/data/data/com.termux/files/home/.node-red/perf_results/monitor_sys_stats.sh ${runTag} node-red ${qosArg} ${mqttArg} ${durationArg}`;\nnode.send([ null, { payload: cmd1 }, { payload: cmd2 }, null ]);\n\n// --------- Generate per-message tick ----------\nif (total === 0) {\n  node.status({ fill:'yellow', shape:'ring', text:'total=0 (no sends)' });\n  return;\n}\n\nconst tick = setInterval(() => {\n  let seq = Number(flow.get(seqKey) || 0) + 1;\n  flow.set(seqKey, seq);\n\n  let i = Number(flow.get(idxKey) || 0);\n  const topic_name = list[i % list.length];\n  flow.set(idxKey, (i + 1) % list.length);\n\n  const ctx = { ...runCtx, topic_name, t_pub: Date.now(), seq, total };\n\n  // Final packet carries kms_control: 'done'\n  if (seq >= total) {\n    clearInterval(tick);\n    node.send([{ kms_ctx: ctx, kms_control: 'done' }, null, null, null]);\n    node.status({ fill:'green', shape:'dot', text:`done ${seq}/${total} (${mode})` });\n    return;\n  }\n\n  // Regular packet\n  node.send([{ kms_ctx: ctx }, null, null, null]);\n\n  // Status pulse\n  const step = Math.max(1, Math.floor(rate));\n  if (seq % step === 0) {\n    node.status({\n      fill:'blue',\n      shape:'dot',\n      text:`${mode}: ${seq}/${total} ‚Ä¢ ${rate.toFixed(2)} msg/s ‚Ä¢ topics:${list.length}`\n    });\n  }\n}, every);\n\nnode.status({\n  fill:'blue',\n  shape:'dot',\n  text:`start ${mode} ‚Ä¢ total=${total} ‚Ä¢ rate‚âà${rate.toFixed(2)} msg/s`\n});\nreturn;\n",
        "outputs": 4,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 520,
        "wires": [
            [
                "9773aea33d970de6"
            ],
            [
                "68fcba64c107a86a"
            ],
            [
                "490dc95edd502102"
            ],
            []
        ]
    },
    {
        "id": "14dc913507ae4350",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Publish picture via Cake",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d7e23934af9f8ad1",
        "x": 1830,
        "y": 960,
        "wires": []
    },
    {
        "id": "70ec185ab66d1fa0",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Publish picture via Sunny",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1dbac324dcb7ed48",
        "x": 1730,
        "y": 760,
        "wires": []
    },
    {
        "id": "acc78a18c7a13119",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Topic key recieved via Cake",
        "topic": "topic/respond/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "d7e23934af9f8ad1",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 120,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "670f5d43fe169bff",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Topic key recieved via Sunny",
        "topic": "topic/respond/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "1dbac324dcb7ed48",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 980,
        "wires": [
            [
                "75d230bbd6974e9c"
            ]
        ]
    },
    {
        "id": "04c974e3d0489b09",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send register via Cake",
        "topic": "topic/register/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "d7e23934af9f8ad1",
        "x": 2520,
        "y": 460,
        "wires": []
    },
    {
        "id": "46b89d3b163e0cf6",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send register via Sunny",
        "topic": "topic/register/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1dbac324dcb7ed48",
        "x": 2490,
        "y": 180,
        "wires": []
    },
    {
        "id": "b177cd5a8e414ff3",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Recieved topic key via Sunny",
        "topic": "topic/key_resp/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "1dbac324dcb7ed48",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 220,
        "y": 1800,
        "wires": [
            []
        ]
    },
    {
        "id": "4553e080649ab1e3",
        "type": "switch",
        "z": "a65d1393aff03429",
        "name": "Send MQTTS payload according to SSID connected",
        "property": "payload.wifi_ssid",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Network-01",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-02",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-A",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "Network-B",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 4,
        "x": 1220,
        "y": 1620,
        "wires": [
            [
                "2d643423f6dc6ec2"
            ],
            [
                "2d643423f6dc6ec2"
            ],
            [
                "a9662d302a35e855"
            ],
            [
                "cdd576c3a55dbdd1"
            ]
        ]
    },
    {
        "id": "a9662d302a35e855",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send topic key request  via Cookie",
        "topic": "topic/key_req/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "fcc9581fb1cd01fb",
        "x": 1660,
        "y": 1580,
        "wires": []
    },
    {
        "id": "2d643423f6dc6ec2",
        "type": "mqtt out",
        "z": "a65d1393aff03429",
        "name": "Send topic key request via Sunny",
        "topic": "topic/key_req/bob",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "1dbac324dcb7ed48",
        "x": 1600,
        "y": 1480,
        "wires": []
    },
    {
        "id": "cf9d9b9dedf684f3",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Load Topics",
        "info": "",
        "x": 150,
        "y": 20,
        "wires": []
    },
    {
        "id": "55bce0a5de798303",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "MQTT Client (BOB)",
        "info": "",
        "x": 110,
        "y": 1300,
        "wires": []
    },
    {
        "id": "34ba0c86fa72c13a",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Recived Topic key and publish data",
        "info": "",
        "x": 160,
        "y": 880,
        "wires": []
    },
    {
        "id": "c9fbbdfa2b2ecc07",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Recieved encrypted data and request topic key",
        "info": "",
        "x": 180,
        "y": 1380,
        "wires": []
    },
    {
        "id": "6e011ddd5cf3623e",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Recieved topic key and decrypt data",
        "info": "",
        "x": 200,
        "y": 1720,
        "wires": []
    },
    {
        "id": "536f750b0a60c734",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Data recieved via Sunny",
        "topic": "data/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "1dbac324dcb7ed48",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 110,
        "y": 1460,
        "wires": [
            []
        ]
    },
    {
        "id": "6a25f879461f7cc6",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Received topic key and decrypt data",
        "func": "// Function ‚Äî Decrypt topic-key response (ECDH secret), verify Sunny's response\n// signature, decrypt image+note for Dashboard, VERIFY sender's data signature,\n// and log secure E2E latency.\n//\n// Outputs:\n//  1) to File node (decrypted image file)          (only when status === \"OK\")\n//  2) to Dashboard (ui_template)                   (only when status === \"OK\")\n//  3) to bob_perf_secure.csv (per-message rows)\n//  4) to summary_latency_secure.csv (per-run summary with drop %)\n\nconst fs = global.get(\"fs\");\nconst crypto = global.get(\"crypto\");\n\n// ---------- A) Decrypt & VERIFY the topic-key RESPONSE ----------\ntry {\n  const encHex = String(msg.payload?.encryptedData || \"\").trim();\n  const ivHex  = String(msg.payload?.iv || \"\").trim();\n  const sigB64 = String(msg.payload?.signature || \"\").trim();\n\n  if (!encHex || !ivHex || !sigB64) {\n    node.error(\"‚ùå Missing encryptedData, iv, or signature in topic/key_resp payload.\");\n    return [null, null, null, null];\n  }\n\n  const secretPath = \"/data/data/com.termux/files/home/.node-red/certs/bob-topic-key-request-secret-key.bin\";\n  if (!fs.existsSync(secretPath)) {\n    node.error(`‚ùå Secret key file not found: ${secretPath}`);\n    return [null, null, null, null];\n  }\n  const secretBin = fs.readFileSync(secretPath);\n  const aesKey = crypto.createHash(\"sha256\").update(secretBin).digest();\n\n  const ivBuf = Buffer.from(ivHex, \"hex\");\n  const ctBuf = Buffer.from(encHex, \"hex\");\n  if (ivBuf.length !== 16) {\n    node.error(`‚ùå Invalid IV length ${ivBuf.length} (expected 16)`);\n    return [null, null, null, null];\n  }\n  const decipherResp = crypto.createDecipheriv(\"aes-256-cbc\", aesKey, ivBuf);\n  const plaintextResp = Buffer.concat([decipherResp.update(ctBuf), decipherResp.final()]).toString(\"utf8\");\n\n  const respObj = JSON.parse(plaintextResp);\n  const topicNameDecrypted = String(respObj.topic_name || \"\");\n  const keyBlobB64Resp     = String(respObj.key_blob_b64 || \"\");\n  const statusResp         = String(respObj.status || \"UNKNOWN\");\n\n  if (!topicNameDecrypted || !keyBlobB64Resp) {\n    node.error(\"‚ùå Decrypted response missing topic_name or key_blob_b64.\");\n    return [null, null, null, null];\n  }\n\n  const sunnyPubPath = \"/data/data/com.termux/files/home/.node-red/certs/sunny-public-key.pem\";\n  if (!fs.existsSync(sunnyPubPath)) {\n    node.error(`‚ùå Sunny public key not found: ${sunnyPubPath}`);\n    return [null, null, null, null];\n  }\n  const sunnyPubPEM = fs.readFileSync(sunnyPubPath, \"utf8\").trim();\n\n  const signedString = `${statusResp}|${topicNameDecrypted}|${keyBlobB64Resp}`;\n  let sigOK = false;\n  try {\n    const verifier = crypto.createVerify(\"sha256\");\n    verifier.update(signedString);\n    verifier.end();\n    sigOK = verifier.verify(sunnyPubPEM, sigB64, \"base64\");\n  } catch (e) {\n    node.error(\"‚ùå Signature verification error (Sunny response): \" + e.message);\n    return [null, null, null, null];\n  }\n  if (!sigOK) {\n    node.error(\"‚ùå Topic-key response signature INVALID (Sunny). Dropping message.\");\n    return [null, null, null, null];\n  }\n\n  const cleanedKey = keyBlobB64Resp.replace(/^\"(.*)\"$/, \"$1\").replace(/\\s+/g, \"\");\n  const topicKeys  = Object.assign({}, flow.get(\"topicKeys\") || {});\n  topicKeys[topicNameDecrypted] = cleanedKey;\n  flow.set(\"topicKeys\", topicKeys);\n\n  msg._topic_name_from_keyresp = topicNameDecrypted;\n  msg._key_b64_from_keyresp    = cleanedKey;\n\n} catch (e) {\n  node.error(\"‚ùå Failed to decrypt/verify topic-key response: \" + e.message);\n  return [null, null, null, null];\n}\n\n// ---------- B) Decrypt image + note ----------\nconst topicName  = msg._topic_name_from_keyresp || String(msg.topic || \"\");\nconst keyBlobB64 = msg._key_b64_from_keyresp   || \"\";\n\nconst iv_b64    = String(flow.get(\"iv_b64\")    || \"\");\nconst ct_b64    = String(flow.get(\"ct_b64\")    || \"\");\nconst ct_nt_b64 = String(flow.get(\"ct_nt_b64\") || \"\");\nconst filename  = String(flow.get(\"filename\")  || \"file.bin\");\n\nif (!topicName || !keyBlobB64 || !iv_b64 || !ct_b64) {\n  node.error(\"‚ùå Missing topic_name/key or iv/ct from flow to decrypt the data message.\");\n  return [null, null, null, null];\n}\n\n// Meta is needed both for status + logging (mode, run_tag, etc.)\nconst meta   = flow.get(\"kms_meta_bob\") || {};\nconst runId  = String(meta.run_id || \"\");\nconst runTag = String(meta.run_tag || \"\");\n\n// Status of this message (for CSV)\nlet status = \"OK\";\n// Whether to send to file/dashboard\nlet deliverToUser = true;\n\nfunction normalizeKey(b64) {\n  const clean = b64.replace(/^\"(.*)\"$/, \"$1\").replace(/\\s+/g, \"\");\n  let k = Buffer.from(clean, \"base64\");\n  if (k.length === 33 && (k[32] === 0x0A || k[32] === 0x00)) k = k.slice(0, 32);\n  return k;\n}\nconst key = normalizeKey(keyBlobB64);\nif (key.length !== 32) {\n  node.error(`‚ùå Invalid key length: ${key.length} (expected 32)`);\n  status = \"decrypt_fail\";\n  deliverToUser = false;\n}\n\n// Even if AES fails, we still want plaintext defined for logging\nlet plaintext = Buffer.alloc(0);\n\nif (status === \"OK\") {\n  const iv = Buffer.from(iv_b64, \"base64\");\n  const ct = Buffer.from(ct_b64, \"base64\");\n  if (iv.length !== 16) {\n    node.error(`‚ùå Invalid IV length ${iv.length} (expected 16)`);\n    status = \"decrypt_fail\";\n    deliverToUser = false;\n  } else {\n    try {\n      const decipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);\n      plaintext = Buffer.concat([decipher.update(ct), decipher.final()]);\n    } catch (e) {\n      node.error(\"‚ùå Decryption failed (image): \" + e.message);\n      status = \"decrypt_fail\";\n      deliverToUser = false;\n    }\n  }\n}\n\nlet noteText  = \"\";\nlet noteTs    = null;\nlet noteHuman = \"\";\nlet noteMsg   = \"\";\n\nif (ct_nt_b64 && status === \"OK\") {\n  try {\n    const ctNote  = Buffer.from(ct_nt_b64, \"base64\");\n    const decNote = crypto.createDecipheriv(\"aes-256-cbc\", key, Buffer.from(iv_b64, \"base64\"));\n    noteText = Buffer.concat([decNote.update(ctNote), decNote.final()]).toString(\"utf8\");\n\n    const m = noteText.match(/(\\d{10,})\\s*$/);\n    if (m) {\n      noteTs    = Number(m[1]);\n      noteMsg   = noteText.slice(0, m.index).trim();\n      noteHuman = new Date(noteTs * 1000).toLocaleString();\n    } else {\n      noteMsg = noteText.trim();\n    }\n  } catch (e) {\n    node.warn(\"‚ö†Ô∏è Decryption of note failed: \" + e.message);\n  }\n} else if (!ct_nt_b64) {\n  node.warn(\"‚ÑπÔ∏è No encrypted note text found in flow context.\");\n}\n\n// ---------- C) VERIFY sender's data signature ----------\n//\n// Sender signed: signer.update(imagePlaintext); signer.update(Buffer.from(note, \"utf8\"));\nif (status === \"OK\") {\n  try {\n    const senderSigB64 = String(flow.get(\"sender_signature_b64\") || \"\").trim();\n    const senderPubPEM = String(flow.get(\"sender_public_key_pem\") || \"\").trim();\n\n    if (!senderSigB64 || !senderPubPEM) {\n      node.warn(\"‚ö†Ô∏è Missing sender signature or public key in flow; skipping sender data signature verification.\");\n    } else if (!noteText) {\n      node.warn(\"‚ö†Ô∏è Decrypted note text empty; cannot safely verify sender signature. Skipping verification.\");\n    } else {\n      const verifier = crypto.createVerify(\"sha256\");\n      verifier.update(plaintext);                     // image bytes\n      verifier.update(Buffer.from(noteText, \"utf8\")); // note text\n      verifier.end();\n\n      const sigOK = verifier.verify(senderPubPEM, senderSigB64, \"base64\");\n      if (!sigOK) {\n        // Distinguish MITM vs other signature failures\n        const mode = String(meta.mode || \"\");\n        status = (mode === \"cookie_sig_shift_3\") ? \"attack_sig_fail\" : \"sig_fail\";\n        deliverToUser = false;\n        node.error(\"‚ùå Sender data signature INVALID (image + note). Dropping decrypted content.\");\n        node.warn(`‚ö†Ô∏è Debug: status=${status}, signature_len=${senderSigB64.length}, note_len=${noteText.length}, img_bytes=${plaintext.length}`);\n      } else {\n        node.warn(\"‚úÖ Sender data signature verified successfully.\");\n      }\n    }\n  } catch (e) {\n    node.error(\"‚ùå Error during sender data signature verification: \" + e.message);\n    status = \"sig_fail\";\n    deliverToUser = false;\n  }\n}\n\n// ---------- D) Outputs for file + dashboard ----------\nconst safeName = filename.replace(/[^A-Za-z0-9._-]/g, \"_\");\n\nconst toFile = {\n  filename: `/data/data/com.termux/files/home/.node-red/certs/${safeName}`,\n  payload: plaintext\n};\n\nconst toDashboard = {\n  topic: topicName,\n  payload: {\n    image_data_url: \"data:image/png;base64,\" + plaintext.toString(\"base64\"),\n    note_text_raw: noteText,\n    note_message: noteMsg,\n    note_ts: noteTs,\n    note_human: noteHuman,\n    filename: safeName\n  }\n};\n\nif (status === \"OK\") {\n  node.warn(`‚úÖ Full decrypt complete for topic \"${topicName}\" ‚Üí content decrypted & signature checked ‚Üí ready for file write & dashboard display.`);\n} else {\n  node.warn(`‚ÑπÔ∏è No file/dashboard output for topic \"${topicName}\" because status=${status}.`);\n}\n\n// ---------- E) Secure E2E performance logging ----------\nlet perfMsgs = [];\nlet sumMsgs  = [];\n\ntry {\n  function fmt(ms) {\n    if (!Number.isFinite(ms)) return \"\";\n    const d  = new Date(ms);\n    const p  = n => String(n).padStart(2, \"0\");\n    const ms3= String(d.getMilliseconds()).padStart(3, \"0\");\n    return `${d.getFullYear()}-${p(d.getMonth()+1)}-${p(d.getDate())} `\n         + `${p(d.getHours())}:${p(d.getMinutes())}:${p(d.getSeconds())}.${ms3}`;\n  }\n  function csv(arr) {\n    return arr.map(v => (v === undefined ? \"\" : v)).join(\",\");\n  }\n\n  const runKey = runId || runTag || \"default\";\n\n  const perfPath = \"/data/data/com.termux/files/home/.node-red/perf_results/bob_perf_secure.csv\";\n  const sumPath  = \"/data/data/com.termux/files/home/.node-red/perf_results/summary_latency_secure.csv\";\n\n  const now   = Date.now();\n  const t_pub = Number(meta.t_pub || 0);\n\n  const DURATION_SEC = Number(meta.duration || 120) || 120;\n  const rateMps      = Number(meta.rate_mps || 0);\n  const msgCountMeta = Number(meta.msg_count || 0);\n\n  let expectedBase;\n  if (Number.isFinite(msgCountMeta) && msgCountMeta > 0) {\n    expectedBase = Math.round(msgCountMeta);\n  } else if (Number.isFinite(rateMps) && rateMps > 0) {\n    expectedBase = Math.round(rateMps * DURATION_SEC);\n  } else {\n    expectedBase = 0;\n  }\n\n  const stateKey = `secure_e2e_${runKey}`;\n  let state = flow.get(stateKey) || {\n    latencies: [],\n    count: 0,\n    expected: expectedBase,\n    firstRecv: 0,\n    lastRecv: 0,\n    summaryWritten: false\n  };\n  if (!state.expected && expectedBase > 0) state.expected = expectedBase;\n\n  if (!state.firstRecv) state.firstRecv = now;\n  state.lastRecv = now;\n\n  let latMs = NaN;\n  // Only treat as latency sample when we actually succeeded (status === \"OK\")\n  if (status === \"OK\" && Number.isFinite(t_pub) && t_pub > 0) {\n    latMs = now - t_pub;\n    state.latencies.push(latMs);\n  }\n  state.count += 1;\n  flow.set(stateKey, state);\n\n  // payload_bytes: decrypted image bytes + note bytes (even if status != OK we can log size)\n  let payloadBytes = 0;\n  if (plaintext && Buffer.isBuffer(plaintext)) {\n    payloadBytes += plaintext.length;\n  }\n  if (noteText) {\n    payloadBytes += Buffer.byteLength(noteText, \"utf8\");\n  }\n\n  const perfHeader = csv([\n    \"ts_human\",\"mode\",\"path_class\",\"run_tag\",\"mqtt_version\",\"qos\",\"rate_mps\",\n    \"run_id\",\"topic\",\"payload_bytes\",\"t_pub_human\",\"t_recv_human\",\n    \"latency_ms\",\"latency_s\",\"status\"\n  ]);\n\n  const perfRow = csv([\n    fmt(now),\n    meta.mode,\n    meta.path_class,\n    meta.run_tag,\n    meta.mqtt_version,\n    meta.qos,\n    meta.rate_mps,\n    runId || runTag || \"\",\n    topicName,\n    payloadBytes,\n    fmt(t_pub),\n    fmt(now),\n    Number.isFinite(latMs) ? latMs : \"\",\n    Number.isFinite(latMs) ? (latMs/1000).toFixed(3) : \"\",\n    status\n  ]);\n\n  const perfHdrWritten = !!flow.get(\"bob_perf_secure_hdr\");\n  const perfFileMissing = (fs && fs.exists\n    ? !fs.existsSync(perfPath)\n    : !perfHdrWritten);\n  if (!perfHdrWritten || perfFileMissing) {\n    perfMsgs.push({ payload: perfHeader, filename: perfPath });\n    flow.set(\"bob_perf_secure_hdr\", true);\n  }\n  perfMsgs.push({ payload: perfRow, filename: perfPath });\n\n  // ---- summary row logic (expected vs observed + drop %) ----\n  const doneFlag      = !!flow.get(`secure_e2e_done_${runKey}`);\n  const graceMs       = 5000;\n  const timeExpired   = state.firstRecv && (now - state.firstRecv) > (DURATION_SEC * 1000 + graceMs);\n  const enoughSamples = state.expected > 0 && state.latencies.length >= state.expected;\n\n  if (!state.summaryWritten && (doneFlag || timeExpired || enoughSamples)) {\n    const arrRaw = state.latencies.slice();\n    if (arrRaw.length > 0) {\n      const observedCount = arrRaw.length;\n\n      let expected = state.expected || expectedBase || observedCount;\n      if (expected < observedCount) expected = observedCount;\n\n      let dropCount = expected - observedCount;\n      if (dropCount < 0) dropCount = 0;\n\n      const dropPct = expected > 0 ? (dropCount / expected) * 100 : 0;\n\n      const arr = arrRaw.sort((a, b) => a - b);\n      const pick = p => arr[Math.min(arr.length - 1, Math.floor(p * (arr.length - 1)))];\n      const median = pick(0.5);\n      const p95    = pick(0.95);\n      const p99    = pick(0.99);\n\n      const sumHeader = csv([\n        \"ts_human\",\"mode\",\"path_class\",\"run_tag\",\"mqtt_version\",\"qos\",\"rate_mps\",\n        \"run_id\",\"count\",\"expected_count\",\"estimated_drop_count\",\"estimated_drop_pct\",\n        \"median_ms\",\"p95_ms\",\"p99_ms\",\"median_s\",\"p95_s\",\"p99_s\"\n      ]);\n\n      const sumRow = csv([\n        fmt(Date.now()),\n        meta.mode,\n        meta.path_class,\n        meta.run_tag,\n        meta.mqtt_version,\n        meta.qos,\n        meta.rate_mps,\n        runId || runTag || \"default\",\n        observedCount,\n        expected,\n        dropCount,\n        dropPct.toFixed(1),\n        median,\n        p95,\n        p99,\n        (median/1000).toFixed(3),\n        (p95/1000).toFixed(3),\n        (p99/1000).toFixed(3)\n      ]);\n\n      const sumHdrWritten = !!flow.get(\"bob_sum_secure_hdr\");\n      const sumFileMissing = (fs && fs.exists\n        ? !fs.existsSync(sumPath)\n        : !sumHdrWritten);\n      if (!sumHdrWritten || sumFileMissing) {\n        sumMsgs.push({ payload: sumHeader, filename: sumPath });\n        flow.set(\"bob_sum_secure_hdr\", true);\n      }\n      sumMsgs.push({ payload: sumRow, filename: sumPath });\n    }\n\n    state.summaryWritten = true;\n    flow.set(stateKey, state);\n    flow.set(`secure_e2e_done_${runKey}`, false);\n  }\n\n} catch (e) {\n  node.warn(\"‚ö†Ô∏è Secure E2E logging failed: \" + e.message);\n}\n\n// Only send file/dashboard if status === \"OK\"\nconst outFile = (status === \"OK\") ? toFile : null;\nconst outDash = (status === \"OK\") ? toDashboard : null;\n\nreturn [outFile, outDash, perfMsgs, sumMsgs];\n",
        "outputs": 4,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 1820,
        "wires": [
            [
                "3eb72e4cfc3d7914"
            ],
            [
                "7ce6b9aca867738f"
            ],
            [
                "59c748fb3812b35d"
            ],
            [
                "a22859cbb92e257d"
            ]
        ]
    },
    {
        "id": "2c10f4efc0a84a28",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "encrypt+sign the picture and publish",
        "func": "// encrypt the picture and publish (e2e data run with KMS meta + t_pub + duration)\n\nconst fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// ---------- 0) Resolve topic/key ----------\nlet topicName = msg.topicName || flow.get('topicName') || flow.get('topic_name') || '';\nlet keyBlobB64 = msg.keyBlobB64;\n\nif (!keyBlobB64) {\n  const topicKeys = flow.get('topicKeys') || {};\n  if (!topicName) topicName = Object.keys(topicKeys)[0] || '';\n  keyBlobB64 = topicName ? topicKeys[topicName] : undefined;\n}\nif (!topicName || !keyBlobB64) {\n  node.error('‚ùå Missing topicName or key for this topic in flow/message context.');\n  return null;\n}\n\n// ---------- 1) Normalize to a 32-byte key ----------\nfunction tryBase64(s) { try { return Buffer.from(s, 'base64'); } catch (e) { return Buffer.alloc(0); } }\nfunction tryBase64Url(s) {\n  let t = s.replace(/-/g, '+').replace(/_/g, '/');\n  const pad = t.length % 4;\n  if (pad === 2) t += '==';\n  else if (pad === 3) t += '=';\n  else if (pad !== 0) t += '==';\n  return tryBase64(t);\n}\nfunction tryHex(s) {\n  try {\n    return (/^[0-9A-Fa-f]+$/.test(s) && (s.length % 2 === 0)) ? Buffer.from(s, 'hex') : Buffer.alloc(0);\n  } catch (e) {\n    return Buffer.alloc(0);\n  }\n}\nconst raw = String(keyBlobB64).replace(/^\"(.*)\"$/, '$1').replace(/\\s+/g, '');\nlet key = tryBase64(raw);\nif (key.length !== 32) key = tryBase64Url(raw);\nif (key.length !== 32) key = tryHex(raw);\nif (key.length === 33 && (key[32] === 0x0A || key[32] === 0x00)) key = key.slice(0, 32);\nif (key.length !== 32) {\n  node.error(`‚ùå Invalid key length after normalization: expected 32 bytes, got ${key.length} (inputLen=${raw.length})`);\n  return null;\n}\n\n// ---------- 2) Read file ----------\nconst imgPath = '/data/data/com.termux/files/home/.node-red/test.png';\nconst filename = 'test.png';\nif (!fs.existsSync(imgPath)) {\n  node.error(`‚ùå File not found: ${imgPath}`);\n  return null;\n}\nconst plaintext = fs.readFileSync(imgPath);\n\n// ---------- 3) Encrypt (AES-256-CBC + PKCS#7) ----------\nconst iv = crypto.randomBytes(16);\n\n// 3a) Encrypt image\nconst cipherImg = crypto.createCipheriv('aes-256-cbc', key, iv);\nconst ctImage = Buffer.concat([cipherImg.update(plaintext), cipherImg.final()]);\n\n// 3b) Encrypt additional text with SAME key and SAME IV\nconst ts = Math.floor(Date.now() / 1000);\nconst humanTime = new Date(ts * 1000).toLocaleString();\nconst note = `This picture is send from Bob ${ts}`;\n\nconst cipherNote = crypto.createCipheriv('aes-256-cbc', key, iv);\nconst ctNote = Buffer.concat([cipherNote.update(Buffer.from(note, 'utf8')), cipherNote.final()]);\n\n// ---------- 3c) Sign plaintext + note with Bob's private key ----------\nconst deviceID      = global.get('deviceID', 'file');\nconst privateKeyPEM = global.get('private_key', 'file');\n\nif (!deviceID || !privateKeyPEM) {\n  node.error('‚ùå Missing deviceID or private_key in global(file) context for signing.');\n  return null;\n}\n\nlet signatureB64;\ntry {\n  const signer = crypto.createSign('sha256');\n  // Sign both the image bytes and the note text\n  signer.update(plaintext);\n  signer.update(Buffer.from(note, 'utf8'));\n  signer.end();\n  signatureB64 = signer.sign(privateKeyPEM, 'base64');\n} catch (e) {\n  node.error('‚ùå Signing failed: ' + e.message);\n  return null;\n}\n\n// ---------- 4) Pull KMS run/test meta (from Sunny's respond) ----------\nconst kmsMeta       = flow.get('kms_meta_from_resp') || {};\nconst runId        = String(kmsMeta.run_id || '');\nconst runTag       = String(kmsMeta.run_tag || '');\nconst rateMps      = Number(kmsMeta.rate_mps || 0);\nconst msgCountMeta = Number(kmsMeta.msg_count || 0);\nconst durationSec  = Number(kmsMeta.duration || 0) || 120;   // duration for the run\nconst tPubFromReg  = Number(kmsMeta.t_pub || 0);             // original t_pub from registration\n\nconst runKey  = runId || runTag || 'default';\nconst seqKey   = `e2e_seq_${runKey}`;\nconst totalKey = `e2e_total_${runKey}`;\n\nlet seq   = Number(flow.get(seqKey)   || 0);\nlet total = Number(flow.get(totalKey) || 0);\n\nif (!Number.isFinite(total) || total <= 0) {\n  if (Number.isFinite(msgCountMeta) && msgCountMeta > 0) {\n    total = msgCountMeta;\n  } else if (Number.isFinite(rateMps) && rateMps > 0) {\n    total = Math.floor(rateMps * durationSec);\n  } else {\n    total = 1; // fallback if nothing known\n  }\n  flow.set(totalKey, total);\n}\n\nseq += 1;\nflow.set(seqKey, seq);\n\nlet kms_control;\nif (seq >= total) {\n  kms_control = 'done';\n}\n\n// ---------- 5) Get SSID ----------\nconst wifi_ssid = String(flow.get('wifi_ssid') || '').trim();\nif (!wifi_ssid) {\n  node.error('‚ùå Missing wifi_ssid in flow');\n  return null;\n}\n\n// ---------- 6) Build MQTT payload (plaintext meta + ciphertext data) ----------\n// Use original registration t_pub as t_pub for end-to-end latency\nconst t_pub = Number.isFinite(tPubFromReg) && tPubFromReg > 0 ? tPubFromReg : Date.now();\n\nconst payload = {\n  alg: 'AES-256-CBC',\n  iv_b64: iv.toString('base64'),\n  ct_b64: ctImage.toString('base64'),\n  filename,\n  mime: 'image/png',\n  msg_ct_b64: ctNote.toString('base64'),\n  msg_ts: ts,\n  wifi_ssid,\n\n  // NEW: sender identity + signature over plaintext+note\n  sender_device_id: deviceID,\n  signature_b64: signatureB64,\n\n  // top-level KMS meta (plaintext) so Bob can start scripts\n  run_id: runId,\n  run_tag: runTag,\n  mode: kmsMeta.mode,\n  path_class: kmsMeta.path_class,\n  mqtt_version: kmsMeta.mqtt_version,\n  qos: kmsMeta.qos,\n  rate_mps: kmsMeta.rate_mps,\n  msg_count: msgCountMeta,\n  duration: durationSec,\n  t_pub,\n  seq,\n  total\n};\n\nif (kms_control) {\n  payload.kms_control = kms_control;   // only present on last message\n}\n\n// also keep nested kms_meta for logging/consistency\npayload.kms_meta = {\n  run_id: runId,\n  run_tag: runTag,\n  mode: kmsMeta.mode,\n  path_class: kmsMeta.path_class,\n  mqtt_version: kmsMeta.mqtt_version,\n  qos: kmsMeta.qos,\n  rate_mps: kmsMeta.rate_mps,\n  msg_count: msgCountMeta,\n  duration: durationSec,\n  t_pub,\n  seq,\n  total,\n  kms_control: kms_control || ''\n};\n\nmsg.topic = topicName;\nmsg.payload = payload;\n\n//node.warn(`üì§ Encryption + signing complete for topic \"${topicName}\" ‚Üí publish seq=${seq}/${total} (run_id=${runId})`);\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 980,
        "wires": [
            [
                "27b3b845874766ab"
            ]
        ]
    },
    {
        "id": "75d230bbd6974e9c",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Decrypt topic registration respond",
        "func": "// Decrypt topic-registration RESPOND, verify, store key, and forward run-meta (incl. msg_count, duration, t_pub)\n\nconst fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// 0) Expect envelope { encryptedData(hex), iv(hex), signature(base64) }\nconst p = msg.payload || {};\nconst encHex = String(p.encryptedData || '').trim();\nconst ivHex  = String(p.iv || '').trim();\nconst sigB64 = String(p.signature || '').trim();\nif (!encHex || !ivHex || !sigB64) {\n  node.warn('‚ÑπÔ∏è Respond envelope missing enc/iv/sig ‚Äî ignoring.');\n  return null;\n}\n\n// 1) Derive AES key from Alice‚Äôs topic-registration secret\nconst secretPath = '/data/data/com.termux/files/home/.node-red/certs/bob-topic-registration-secret-key.bin';\nlet secretBin;\ntry {\n  secretBin = fs.readFileSync(secretPath);\n} catch (e) {\n  node.error(`‚ùå Cannot read secret key at ${secretPath}: ${e.message}`);\n  return null;\n}\nconst aesKey = crypto.createHash('sha256').update(secretBin).digest();\n\n// 2) Decrypt (AES-256-CBC)\nlet obj;\ntry {\n  const iv = Buffer.from(ivHex, 'hex');\n  const ct = Buffer.from(encHex, 'hex');\n  if (iv.length !== 16) {\n    node.warn(`‚ÑπÔ∏è Invalid IV length ${iv.length}; ignoring.`);\n    return null;\n  }\n  const decipher = crypto.createDecipheriv('aes-256-cbc', aesKey, iv);\n  const dec = Buffer.concat([decipher.update(ct), decipher.final()]).toString('utf8');\n  obj = JSON.parse(dec);\n} catch (e) {\n  node.warn('‚ÑπÔ∏è Decryption/parse failed ‚Äî ignoring this message: ' + e.message);\n  return null;\n}\n\n// 3) Verify signature with Sunny‚Äôs public key\nlet sunnyPub;\ntry {\n  sunnyPub = fs.readFileSync('/data/data/com.termux/files/home/.node-red/certs/sunny-public-key.pem', 'utf8').trim();\n} catch (e) {\n  node.error('‚ùå Cannot read sunny-public-key.pem: ' + e.message);\n  return null;\n}\n\nconst status    = String(obj.status || '');\nconst topicName = String(obj.topic_name || '');\nconst keyBlobB64Raw = String(obj.key_blob_b64 || '')\n  .replace(/^\"(.*)\"$/, '$1')\n  .replace(/\\s+/g, '');\nif (!status || !topicName || !keyBlobB64Raw) {\n  node.warn('‚ÑπÔ∏è Decrypted payload missing status/topic_name/key_blob_b64 ‚Äî ignoring.');\n  return null;\n}\n\nlet verified = false;\ntry {\n  const canonical = `${status}|${topicName}|${keyBlobB64Raw}`;\n  const verifier = crypto.createVerify('sha256');\n  verifier.update(canonical);\n  verifier.end();\n  verified = verifier.verify(sunnyPub, sigB64, 'base64');\n} catch (e) {\n  node.warn('‚ÑπÔ∏è Signature verify error ‚Äî ignoring: ' + e.message);\n  return null;\n}\nif (!verified) {\n  node.warn('‚ÑπÔ∏è Signature invalid ‚Äî ignoring.');\n  return null;\n}\n\n// 4) Validate the key is really 32 bytes\nlet keyBuf;\ntry {\n  const b64 = keyBlobB64Raw\n    .replace(/-/g, '+')\n    .replace(/_/g, '/')\n    .padEnd(Math.ceil(keyBlobB64Raw.length / 4) * 4, '=');\n  keyBuf = Buffer.from(b64, 'base64');\n} catch (e) {\n  keyBuf = Buffer.alloc(0);\n}\nif (keyBuf.length !== 32) {\n  node.warn(`‚ÑπÔ∏è Invalid topic key length (got ${keyBuf.length} bytes) ‚Äî ignoring.`);\n  return null;\n}\n\n//node.warn(`üîì Decrypt/Verify OK for topic \"${topicName}\" ‚Äî 32B key accepted.`);\n\n// 5) Store key\nconst topicKeys = Object.assign({}, flow.get('topicKeys') || {});\ntopicKeys[topicName] = keyBlobB64Raw;  // keep as b64 for downstream\nflow.set('topicKeys', topicKeys);\n\n// 6) Forward KMS run/test metadata from Sunny (incl. msg_count, duration, t_pub)\nconst meta = {\n  run_id:     String(obj.run_id || ''),\n  run_tag:    String(obj.run_tag || ''),\n  mode:       obj.mode,\n  path_class: obj.path_class,\n  mqtt_version: obj.mqtt_version,\n  qos:        obj.qos,\n  rate_mps:   obj.rate_mps,\n  msg_count:  Number(obj.msg_count || 0),\n  duration:   Number(obj.duration || 0),\n  t_pub:      Number(obj.t_pub || 0)\n};\nflow.set('kms_meta_from_resp', meta);\nmsg.meta = meta;\n\nmsg.topicName  = topicName;\nmsg.keyBlobB64 = keyBlobB64Raw;\nmsg.payload = {\n  status,\n  topic_name: topicName,\n  key_blob_b64: keyBlobB64Raw,\n  verified: true\n};\n\n// simple counter for visual feedback\nconst cntKey = 'alice_resp_count';\nlet cnt = Number(flow.get(cntKey) || 0) + 1;\nflow.set(cntKey, cnt);\nnode.status({ fill: 'blue', shape: 'dot', text: `respond ok √ó${cnt}` });\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 1040,
        "wires": [
            [
                "32936eb3625e9a15"
            ]
        ]
    },
    {
        "id": "7ce6b9aca867738f",
        "type": "ui_template",
        "z": "a65d1393aff03429",
        "group": "e1aa51208d717e6c",
        "name": "Display Image",
        "order": 0,
        "width": "6",
        "height": "10",
        "format": "<div style=\"display:flex;flex-direction:column;align-items:center;text-align:center;margin-top:10px;\">\n\n    <!-- Message Text -->\n    <div style=\"font-size:16px;font-weight:600;color:#333;margin-bottom:4px;\">\n        {{msg.payload.note_message || 'No note text'}}\n    </div>\n\n    <!-- Human-readable timestamp -->\n    <div style=\"font-size:14px;color:#666;margin-bottom:10px;\" ng-if=\"msg.payload.note_human\">\n        {{msg.payload.note_human}}\n    </div>\n\n    <!-- Image -->\n    <img ng-src=\"{{msg.payload.image_data_url}}\"\n         alt=\"{{msg.payload.filename}}\"\n         style=\"\n            max-width:100%;\n            max-height:70vh;        /* prevent image from exceeding viewport height */\n            object-fit:contain;     /* scale without cropping */\n            height:auto;\n            border-radius:8px;\n            box-shadow:0 2px 8px rgba(0,0,0,.2);\n         \"\n    />\n</div>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 980,
        "y": 1800,
        "wires": [
            []
        ]
    },
    {
        "id": "b2d856faa11bec21",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "Load topics.csv (on deploy)",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.8,
        "topic": "",
        "x": 180,
        "y": 100,
        "wires": [
            [
                "6e72e40b495057c1"
            ]
        ]
    },
    {
        "id": "6e72e40b495057c1",
        "type": "file in",
        "z": "a65d1393aff03429",
        "name": "Read /etc/mosquitto/perf_results/topics.csv",
        "filename": "/data/data/com.termux/files/home/.node-red/perf_results/topics.csv",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 670,
        "y": 100,
        "wires": [
            [
                "7d22323371ff8ac6"
            ]
        ]
    },
    {
        "id": "7d22323371ff8ac6",
        "type": "csv",
        "z": "a65d1393aff03429",
        "name": "Parse CSV (header: topic)",
        "sep": ",",
        "hdrin": true,
        "hdrout": false,
        "multi": "mult",
        "ret": "\\n",
        "temp": "topic",
        "skip": "0",
        "strings": true,
        "include_empty_strings": false,
        "include_null_values": false,
        "x": 990,
        "y": 100,
        "wires": [
            [
                "1656e6f55692df14"
            ]
        ]
    },
    {
        "id": "1656e6f55692df14",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Merge into flow.registeredTopics",
        "func": "const rows = Array.isArray(msg.payload) ? msg.payload : [];\nlet list = flow.get('registeredTopics') || [];\nfor (const r of rows) { const t = String(r.topic || '').trim(); if (t && !list.includes(t)) list.push(t); }\nflow.set('registeredTopics', list);\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1110,
        "y": 160,
        "wires": [
            []
        ]
    },
    {
        "id": "d98c776d11e38caf",
        "type": "inject",
        "z": "a65d1393aff03429",
        "name": "On start",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.5,
        "topic": "",
        "x": 110,
        "y": 300,
        "wires": [
            [
                "3ee318ba741387bd",
                "32d9dd22266d405b"
            ]
        ]
    },
    {
        "id": "3ee318ba741387bd",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Init list",
        "func": "if (!Array.isArray(flow.get('registeredTopics'))) { flow.set('registeredTopics', []); }\nreturn msg;",
        "outputs": 1,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 220,
        "wires": [
            []
        ]
    },
    {
        "id": "32d9dd22266d405b",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Build dropdown",
        "func": "let list = flow.get('registeredTopics') || [];\nlist = list.map(t => String(t)).filter(Boolean);\nlet current = flow.get('topic_name') || '';\nif (!current && list.length) current = list[0];\nreturn [{ options: list, payload: current }];",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 340,
        "y": 320,
        "wires": [
            [
                "ec6b036b9c696516"
            ]
        ]
    },
    {
        "id": "ec6b036b9c696516",
        "type": "ui_dropdown",
        "z": "a65d1393aff03429",
        "name": "Select Topic",
        "label": "Select Topic",
        "tooltip": "Choose a previously typed topic",
        "place": "choose a topic",
        "group": "0a27318785db4493",
        "order": 1,
        "width": 0,
        "height": 0,
        "passthru": true,
        "multiple": false,
        "options": [],
        "payload": "",
        "topic": "",
        "topicType": "str",
        "className": "",
        "x": 570,
        "y": 300,
        "wires": [
            [
                "d82e9b88868a31e3"
            ]
        ]
    },
    {
        "id": "46218bada2ca8881",
        "type": "ui_template",
        "z": "a65d1393aff03429",
        "group": "0a27318785db4493",
        "name": "New topic‚Ä¶ (popup)",
        "order": 2,
        "width": 0,
        "height": 0,
        "format": "<button id=\"btn-new-topic\" class=\"md-raised md-primary\">New topic‚Ä¶</button>\n<script>\n(function(scope){\n function bind(){\n var btn = document.getElementById('btn-new-topic');\n if (!btn || btn._bound) return;\n btn._bound = true;\n btn.addEventListener('click', function(){\n var t = window.prompt('Enter new topic','');\n if (t && t.trim()) {\n scope.send({payload: t.trim(), topic:'new-topic'});\n }\n });\n }\n bind();\n scope.$watch('msg', function(){ setTimeout(bind, 0); });\n})(scope);\n</script>",
        "storeOutMessages": true,
        "fwdInMessages": true,
        "resendOnRefresh": true,
        "templateScope": "local",
        "className": "",
        "x": 140,
        "y": 160,
        "wires": [
            [
                "f7c5216462ff26f7"
            ]
        ]
    },
    {
        "id": "f7c5216462ff26f7",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Save new topic ‚Üí list + select",
        "func": "const topic = String(msg.payload || '').trim();\nif (!topic) { return null; }\nlet list = flow.get('registeredTopics') || [];\nif (!list.includes(topic)) list.push(topic);\nflow.set('registeredTopics', list);\nflow.set('topic_name', topic);\nnode.send([ { action: 'rebuild' }, { payload: topic } ]);\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 200,
        "wires": [
            [
                "32d9dd22266d405b"
            ],
            [
                "d82e9b88868a31e3"
            ]
        ]
    },
    {
        "id": "d82e9b88868a31e3",
        "type": "function",
        "z": "a65d1393aff03429",
        "name": "Set topic in flow",
        "func": "flow.set('topic_name', String(msg.payload || '').trim());\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 280,
        "wires": [
            [
                "9773aea33d970de6"
            ]
        ]
    },
    {
        "id": "c55eb7bab1bd356b",
        "type": "comment",
        "z": "a65d1393aff03429",
        "name": "Experiment Inejct node",
        "info": "",
        "x": 160,
        "y": 380,
        "wires": []
    },
    {
        "id": "153d0807abeb9dbe",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Topic key recieved via Cookie",
        "topic": "topic/respond/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "fcc9581fb1cd01fb",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 1060,
        "wires": [
            []
        ]
    },
    {
        "id": "9c94fb02b23bfdb4",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Data recieved via Cookie",
        "topic": "data/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "fcc9581fb1cd01fb",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 110,
        "y": 1540,
        "wires": [
            []
        ]
    },
    {
        "id": "ecd8decd193bbe04",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Data recieved via Cake",
        "topic": "data/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "b724a5515717df88",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 100,
        "y": 1620,
        "wires": [
            [
                "e1370b5c1a2c1447"
            ]
        ]
    },
    {
        "id": "ca717e794715400c",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Recieved topic key via Cookie",
        "topic": "topic/key_resp/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "9cddc1bd885980b7",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 220,
        "y": 1860,
        "wires": [
            []
        ]
    },
    {
        "id": "facd359091198308",
        "type": "mqtt in",
        "z": "a65d1393aff03429",
        "name": "Recieved topic key via Cake",
        "topic": "topic/key_resp/bob",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "d7e23934af9f8ad1",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 240,
        "y": 1920,
        "wires": [
            [
                "6a25f879461f7cc6"
            ]
        ]
    },
    {
        "id": "fcc9581fb1cd01fb",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.153.1",
        "port": "8883",
        "tls": "2a0ac1241fc34ca9",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "d7e23934af9f8ad1",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.154.1",
        "port": "8883",
        "tls": "f9d2c83bebecb3ef",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "verifyservercert": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "1dbac324dcb7ed48",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "8883",
        "tls": "39cd027928eb4a94",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "e1aa51208d717e6c",
        "type": "ui_group",
        "name": "Image",
        "tab": "f9317684d51e5ac2",
        "order": 1,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "0a27318785db4493",
        "type": "ui_group",
        "name": "Topic",
        "tab": "16051b3dd3d4b4f9",
        "order": 1,
        "disp": true,
        "width": 6,
        "collapse": false,
        "className": ""
    },
    {
        "id": "b724a5515717df88",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.154.1",
        "port": "8883",
        "tls": "d9f4fcfdc2a69ffa",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "9cddc1bd885980b7",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.153.1",
        "port": "8883",
        "tls": "4e3e159d8e243951",
        "clientid": "",
        "autoConnect": true,
        "usetls": true,
        "protocolVersion": 4,
        "keepalive": 60,
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "2a0ac1241fc34ca9",
        "type": "tls-config",
        "name": "",
        "cert": "/data/data/com.termux/files/home/.node-red/certs/bob.pem",
        "key": "/data/data/com.termux/files/home/.node-red/certs/bob-key.pem",
        "ca": "/data/data/com.termux/files/home/.node-red/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cookie",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "f9d2c83bebecb3ef",
        "type": "tls-config",
        "name": "",
        "cert": "/data/data/com.termux/files/home/.node-red/certs/bob.pem",
        "key": "/data/data/com.termux/files/home/.node-red/certs/bob-key.pem",
        "ca": "/data/data/com.termux/files/home/.node-red/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cake",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "39cd027928eb4a94",
        "type": "tls-config",
        "name": "",
        "cert": "/data/data/com.termux/files/home/.node-red/certs/bob.pem",
        "key": "/data/data/com.termux/files/home/.node-red/certs/bob-key.pem",
        "ca": "/data/data/com.termux/files/home/.node-red/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "sunny",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "f9317684d51e5ac2",
        "type": "ui_tab",
        "name": "Data Recieve (Bob)",
        "icon": "dashboard",
        "order": 2,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "16051b3dd3d4b4f9",
        "type": "ui_tab",
        "name": "Data Transfer (Bob)",
        "icon": "dashboard",
        "order": 1,
        "disabled": false,
        "hidden": false
    },
    {
        "id": "d9f4fcfdc2a69ffa",
        "type": "tls-config",
        "name": "",
        "cert": "/data/data/com.termux/files/home/.node-red/certs/bob.pem",
        "key": "/data/data/com.termux/files/home/.node-red/certs/bob-key.pem",
        "ca": "/data/data/com.termux/files/home/.node-red/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cake",
        "verifyservercert": true,
        "alpnprotocol": ""
    },
    {
        "id": "4e3e159d8e243951",
        "type": "tls-config",
        "name": "",
        "cert": "/data/data/com.termux/files/home/.node-red/certs/bob.pem",
        "key": "/data/data/com.termux/files/home/.node-red/certs/bob-key.pem",
        "ca": "/data/data/com.termux/files/home/.node-red/certs/MQTTS.pem",
        "certname": "",
        "keyname": "",
        "caname": "",
        "servername": "cookie",
        "verifyservercert": true,
        "alpnprotocol": ""
    }
]
