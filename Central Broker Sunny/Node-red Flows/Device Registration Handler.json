[
    {
        "id": "6677d7ade5781d37",
        "type": "tab",
        "label": "Device Registration Handler",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "754287e430557b99",
        "type": "mqtt in",
        "z": "6677d7ade5781d37",
        "name": "Registration Request",
        "topic": "registration/request/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "47b12596f39b9eb8",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 140,
        "y": 560,
        "wires": [
            [
                "c0e2af7dbc193c83",
                "7aa08ed0106b83c9"
            ]
        ]
    },
    {
        "id": "c0f21764a691e395",
        "type": "function",
        "z": "6677d7ade5781d37",
        "name": "Prepare Registration Respond",
        "func": "const fs = global.get('fs');\nconst crypto = global.get('crypto');\n\n// Paths to required files\nconst certFilePath = \"/etc/mosquitto/certs/MQTTS.pem\";\nconst secretKeyPath = `/etc/mosquitto/certs/${msg.device_name}-registration-secret-key.bin`; // AES-256 Secret Key\nconst prov_pass_path = \"/etc/step-ca/secrets/provisioner_password\";\nconst fingerprint=msg.payload;\n//node.warn(fingerprint);\nconst ca_url = \"https://192.168.151.1:8443\";\n\n\n\n// Retrieve from context\nlet jwt = flow.get('jwt');\nlet deviceID = flow.get('deviceID');\nlet registered_at = flow.get('registerd_at');\nlet is_broker = flow.get('is_broker');\n\n// Retrieve Sunny's keys from global context\nlet sunnyPrivateKey = global.get(\"private_key\", \"file\");\nlet sunnyPublicKey = global.get(\"public_key\", \"file\");\n\nif (!sunnyPrivateKey || !sunnyPublicKey || !jwt || !deviceID || !registered_at || is_broker === undefined) {\n    node.error(\"❌ Missing one or more required variables from context.\");\n    return null;\n}\n\n// Function to read UTF-8 file contents\nfunction readFileSync(filePath) {\n    return fs.readFileSync(filePath, 'utf8').trim();\n}\n\n// Read cert files\nconst MQTTS_CA_Certificate = readFileSync(certFilePath);\nconst prov_pass= readFileSync(prov_pass_path);\n\n// Read binary secret key and derive AES key\nconst secretKEYPEM = fs.readFileSync(secretKeyPath);  // binary\nconst aesKey = crypto.createHash('sha256').update(secretKEYPEM).digest();\n\n// --- Step 1: Concatenate Fields for Signing ---\nconst dataToSign = `${deviceID}|${MQTTS_CA_Certificate}|${fingerprint}|${ca_url}|${prov_pass}|${jwt}|${registered_at}|${sunnyPublicKey}|${is_broker}`;\n\n// --- Step 2: Sign with Sunny's private key ---\nconst signer = crypto.createSign('sha256');\nsigner.update(dataToSign);\nsigner.end();\nconst signature = signer.sign(sunnyPrivateKey, 'base64');\n\n// --- Step 3: Prepare object for encryption ---\nconst toEncrypt = {\n    deviceID: deviceID,\n    MQTTS_CA_Certificate: MQTTS_CA_Certificate,\n    fingerprint:fingerprint,\n    ca_url:ca_url,\n    prov_pass:prov_pass,\n    jwt: jwt,\n    registered_at: registered_at,\n    sunnyPublicKey: sunnyPublicKey,\n    is_broker: is_broker\n};\n\n// --- Step 4: AES-256-CBC encryption ---\nconst iv = crypto.randomBytes(16);\nconst cipher = crypto.createCipheriv('aes-256-cbc', aesKey, iv);\nlet encrypted = cipher.update(JSON.stringify(toEncrypt), 'utf8', 'hex');\nencrypted += cipher.final('hex');\n\n// --- Step 5: MQTT Payload ---\nmsg.payload = {\n    encryptedData: encrypted,\n    iv: iv.toString('hex'),\n    sign: signature\n};\n\nmsg.topic = `registration/respond/${msg.device_name}`;\n\n// Logging\n//node.warn(`Data to Sign: ${dataToSign}`);\n//node.warn(`Signature: ${signature}`);\n//node.warn(`Encrypted Data: ${encrypted}`);\n//node.warn(`MQTT Topic: ${msg.topic}`);\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1870,
        "y": 480,
        "wires": [
            [
                "7ddb3736d89d2e44"
            ]
        ]
    },
    {
        "id": "d0180ea49e689e8e",
        "type": "comment",
        "z": "6677d7ade5781d37",
        "name": "Recived Registration Request data. Generate Deviceid, JWT, MQTTS config for registered devices and insert these data into database",
        "info": "",
        "x": 490,
        "y": 500,
        "wires": []
    },
    {
        "id": "d23ad7c0cd6d1098",
        "type": "exec",
        "z": "6677d7ade5781d37",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Insert Data to Device Profile Table",
        "x": 900,
        "y": 560,
        "wires": [
            [
                "a2ea506f1e71fc7d"
            ],
            [],
            []
        ]
    },
    {
        "id": "a2ea506f1e71fc7d",
        "type": "function",
        "z": "6677d7ade5781d37",
        "name": "Prepare Data for Keys Table",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: Retrieve device ID from flow context ---\nlet deviceID = flow.get('deviceID'); \nif (!deviceID) {\n    node.error(\"❌ deviceID not found in flow context!\");\n    return null;\n}\n\n// --- Step 2: Define paths ---\nconst publicKeyPath = `/etc/mosquitto/certs/${msg.device_name}-public-key.pem`;\nconst secretKeyPath = `/etc/mosquitto/certs/${msg.device_name}-registration-secret-key.bin`;\n\n// --- Step 3: Read public key ---\nlet publicKey;\ntry {\n    publicKey = fs.readFileSync(publicKeyPath, 'utf8').trim();\n} catch (err) {\n    node.error(\"❌ Failed to read public key file: \" + err.message);\n    return null;\n}\n\n// --- Step 4: Read registration secret key (binary) ---\nlet secretKeyBuffer;\ntry {\n    secretKeyBuffer = fs.readFileSync(secretKeyPath);  // Raw binary\n} catch (err) {\n    node.error(\"❌ Failed to read registration secret key file: \" + err.message);\n    return null;\n}\n\n// --- Step 5: SQLCipher config ---\nconst dbPath = \"/etc/mosquitto/certs/update_database.db\";\nconst pragmaKey = env.get(\"DB_PASSWORD\");\n\n// --- Step 6: Convert to hex for BLOB insert ---\nconst secretKeyHex = secretKeyBuffer.toString('hex');\n\n// --- Step 7: Insert into Keys table (raw BLOB insert) ---\nconst sqlInsert = `\nPRAGMA key = '${pragmaKey}';\nINSERT OR REPLACE INTO Keys (device_id, private_key, public_key, registration_key)\nVALUES ('${deviceID}', NULL, '${publicKey}', X'${secretKeyHex}');\n`;\nmsg.payload = `sqlcipher ${dbPath} <<< \"${sqlInsert.trim()}\"`;\nconst devicename= flow.get('devicename');\n// --- Step 8: MQTT Payload (hex format included) ---\nmsg.mqtt_payload = {\n    device_id: deviceID,\n    devicename:devicename,\n    public_key: publicKey\n    // Optionally, use Base64 instead: secretKeyBuffer.toString('base64')\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1220,
        "y": 560,
        "wires": [
            [
                "68b6fa73194adef7",
                "9c4a551e04e0fb4d"
            ]
        ]
    },
    {
        "id": "68b6fa73194adef7",
        "type": "exec",
        "z": "6677d7ade5781d37",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Instert Data into Keys Table",
        "x": 1260,
        "y": 480,
        "wires": [
            [
                "f89bdec5e036a4f3"
            ],
            [],
            []
        ]
    },
    {
        "id": "7ddb3736d89d2e44",
        "type": "mqtt out",
        "z": "6677d7ade5781d37",
        "name": "Registration Respond",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "23910bfd6ab1a872",
        "x": 1880,
        "y": 540,
        "wires": []
    },
    {
        "id": "9c0ad7c20bbff15a",
        "type": "change",
        "z": "6677d7ade5781d37",
        "name": "Set MQTTS Payload to sync database",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 550,
        "y": 620,
        "wires": [
            [
                "8799d394db10a9cf"
            ]
        ]
    },
    {
        "id": "9c4a551e04e0fb4d",
        "type": "change",
        "z": "6677d7ade5781d37",
        "name": "Set MQTTS Payload to sync database",
        "rules": [
            {
                "t": "set",
                "p": "payload",
                "pt": "msg",
                "to": "msg.mqtt_payload",
                "tot": "jsonata"
            }
        ],
        "action": "",
        "property": "",
        "from": "",
        "to": "",
        "reg": false,
        "x": 1290,
        "y": 620,
        "wires": [
            [
                "fd872aed5143c9b3"
            ]
        ]
    },
    {
        "id": "a2a7444bf00a3fbd",
        "type": "mqtt in",
        "z": "6677d7ade5781d37",
        "name": "Subscribe Public Key",
        "topic": "keys/public key/+",
        "qos": "0",
        "datatype": "auto-detect",
        "broker": "47b12596f39b9eb8",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 320,
        "wires": [
            [
                "532e3e74c9e5451e"
            ]
        ]
    },
    {
        "id": "532e3e74c9e5451e",
        "type": "function",
        "z": "6677d7ade5781d37",
        "name": "Define Publisher",
        "func": "const fs = global.get('fs');\nlet topicParts = msg.topic.split(\"/\");\nmsg.device_name = topicParts[2]; // Extract device_id from the topic\n\nlet publicKey = msg.payload;  // Public key from payload\nlet publicKeyPath = `/etc/mosquitto/certs/${msg.device_name}-public-key.pem`;\nlet secretKeyPath = `/etc/mosquitto/certs/${msg.device_name}-registration-secret-key.bin`;\n\nfs.writeFileSync(publicKeyPath, publicKey, 'utf8');\nnode.log(`Public key written to ${publicKeyPath}`);\n\n// Prepare command for the Exec node\nmsg.payload = `openssl pkeyutl -derive -inkey /etc/mosquitto/certs/sunny-private-key.pem -peerkey ${publicKeyPath} -out ${secretKeyPath}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 440,
        "y": 340,
        "wires": [
            [
                "6961ea491ae43046"
            ]
        ]
    },
    {
        "id": "6961ea491ae43046",
        "type": "exec",
        "z": "6677d7ade5781d37",
        "command": "",
        "addpay": "payload",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Registration Secret Key Generation",
        "x": 700,
        "y": 320,
        "wires": [
            [
                "c6c6ebc447d88b2f"
            ],
            [],
            []
        ]
    },
    {
        "id": "c6c6ebc447d88b2f",
        "type": "function",
        "z": "6677d7ade5781d37",
        "name": "Prepare to publish Sunny public key",
        "func": "const fs = global.get('fs');\n\n// --- Step 1: Get device name from msg ---\nlet deviceName = msg.device_name;\n\n// --- Step 2: Retrieve Sunny’s public key from global context (file scope) ---\nlet sunnyPublicKey = global.get(\"public_key\", \"file\");\n\nif (!sunnyPublicKey) {\n    node.error(\"❌ Sunny's public key not found in global context.\");\n    return null;\n}\n\n// --- Step 3: Prepare payload with ONLY the public key ---\nmsg.payload = {\n    public_key: sunnyPublicKey\n};\n\n// --- Step 4: Set dynamic topic for MQTT ---\nmsg.topic = `keys/registration/${deviceName}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 260,
        "wires": [
            [
                "2acb380451563bdd"
            ]
        ]
    },
    {
        "id": "2acb380451563bdd",
        "type": "mqtt out",
        "z": "6677d7ade5781d37",
        "name": "Publish Sunny Public Key",
        "topic": "",
        "qos": "0",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "47b12596f39b9eb8",
        "x": 1250,
        "y": 320,
        "wires": []
    },
    {
        "id": "2c75a92748c147ce",
        "type": "comment",
        "z": "6677d7ade5781d37",
        "name": "Generate Registration Secret Key and publish Sunny Public Key",
        "info": "",
        "x": 310,
        "y": 260,
        "wires": []
    },
    {
        "id": "8799d394db10a9cf",
        "type": "mqtt out",
        "z": "6677d7ade5781d37",
        "name": "Sync Device Profile Table",
        "topic": "sync/data/device_profile",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "47b12596f39b9eb8",
        "x": 650,
        "y": 680,
        "wires": []
    },
    {
        "id": "fd872aed5143c9b3",
        "type": "mqtt out",
        "z": "6677d7ade5781d37",
        "name": "Sync Keys Table",
        "topic": "sync/data/keys_",
        "qos": "2",
        "retain": "",
        "respTopic": "",
        "contentType": "",
        "userProps": "",
        "correl": "",
        "expiry": "",
        "broker": "47b12596f39b9eb8",
        "x": 1360,
        "y": 680,
        "wires": []
    },
    {
        "id": "fe220587e2815140",
        "type": "comment",
        "z": "6677d7ade5781d37",
        "name": " MQTT Central Broker (Sunny)",
        "info": "",
        "x": 220,
        "y": 180,
        "wires": []
    },
    {
        "id": "f89bdec5e036a4f3",
        "type": "exec",
        "z": "6677d7ade5781d37",
        "command": "step certificate fingerprint /home/step/.step/certs/root_ca.crt",
        "addpay": "",
        "append": "",
        "useSpawn": "false",
        "timer": "",
        "winHide": false,
        "oldrc": false,
        "name": "Check CA certificate finger print",
        "x": 1570,
        "y": 480,
        "wires": [
            [
                "c0f21764a691e395"
            ],
            [],
            []
        ]
    },
    {
        "id": "c0e2af7dbc193c83",
        "type": "function",
        "z": "6677d7ade5781d37",
        "name": "Decrypt and prepare data for Deviceprofile ",
        "func": "const fs = global.get('fs');\nconst crypto = global.get(\"crypto\");\nconst jwt = global.get(\"jwt\");\n\ntry {\n    // --- Step 1: Extract device_name from topic ---\n    let topicParts = msg.topic.split(\"/\");\n    msg.device_name = topicParts[2]; // e.g. \"jonny\"\n\n    // --- Step 2: Build paths ---\n    const publicKeyPath = `/etc/mosquitto/certs/${msg.device_name}-public-key.pem`;\n    const secretKeyPath = `/etc/mosquitto/certs/${msg.device_name}-registration-secret-key.bin`;\n\n    // --- Step 3: Read files ---\n    const publicKeyPEM = fs.readFileSync(publicKeyPath, 'utf8');\n    const secretKEYPEM = fs.readFileSync(secretKeyPath);\n\n    // --- Step 4: AES decrypt ---\n    const aesKey = crypto.createHash('sha256').update(secretKEYPEM).digest();\n    const { encryptedData, iv, sign } = msg.payload;\n    const decipher = crypto.createDecipheriv('aes-256-cbc', aesKey, Buffer.from(iv, 'hex'));\n    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n\n    const decryptedData = JSON.parse(decrypted);\n\n    // --- Step 5: Verify signature ---\n    const dataToVerify = `${decryptedData.macAddresses.join(',')}|${decryptedData.device_name}`;\n    const verifier = crypto.createVerify('sha256');\n    verifier.update(dataToVerify);\n    verifier.end();\n    const isVerified = verifier.verify(publicKeyPEM, sign, 'base64');\n    if (!isVerified) { node.error(\"❌ Signature invalid\"); return null; }\n\n    // --- Step 6: Registration fields ---\n    const deviceName = msg.device_name; // reuse from topic\n    const macAddresses = decryptedData.macAddresses || [];\n    const macAddress1 = macAddresses[0] || \"00:00:00:00:00:00\";\n    const macAddress2 = macAddresses[1] || \"00:00:00:00:00:00\";\n    const isBroker = macAddress2 !== \"00:00:00:00:00:00\" ? 1 : 0;\n\n    const deviceId = crypto.createHash('sha256').update(macAddress1 + macAddress2).digest('hex');\n    flow.set('deviceID', deviceId);\n    flow.set('devicename', deviceName);\n\n    const registrationTime = Math.floor(Date.now() / 1000); // iat\n\n    // --- Step 7: JWT sign (add exp = iat + 900s = 15 min) ---\n    const privateKey = global.get(\"private_key\", \"file\");\n    if (!privateKey) { node.error(\"❌ Sunny's private key not found!\"); return null; }\n\n    const jwtPayload = {\n        device_id: deviceId,\n        device_name: deviceName,\n        mac_address_1: macAddress1,\n        mac_address_2: macAddress2,\n        iat: registrationTime,\n        exp: registrationTime + 2700,   // <<< 15 minutes\n        is_broker: isBroker\n    };\n    const jwtToken = jwt.sign(jwtPayload, privateKey, { algorithm: 'ES256' });\n    flow.set('jwt', jwtToken);\n\n    // --- Step 8: SQLCipher insert ---\n    const dbPath = \"/etc/mosquitto/certs/update_database.db\";\n    const pragmaKey = env.get(\"DB_PASSWORD\");\n    const sqlInsert = `\nPRAGMA key = '${pragmaKey}';\nINSERT OR REPLACE INTO DeviceProfile (device_id, device_name, mac_address_1, mac_address_2, jwt_token, is_broker, authentication_status, registered_at)\nVALUES ('${deviceId}', '${deviceName}', '${macAddress1}', '${macAddress2}', '${jwtToken}', ${isBroker}, NULL, ${registrationTime});\n`.trim();\n\n    msg.payload = `sqlcipher ${dbPath} <<< \"${sqlInsert}\"`;\n\n    // --- Step 9: MQTT payload ---\n    msg.mqtt_payload = {\n        device_id: deviceId,\n        device_name: deviceName,\n        mac_address_1: macAddress1,\n        mac_address_2: macAddress2,\n        is_broker: isBroker,\n        authentication_status: null,\n        registered_at: registrationTime\n    };\n\n    return msg;\n} catch (err) {\n    node.error(\"Error: \" + err.message);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 560,
        "wires": [
            [
                "9c0ad7c20bbff15a",
                "d23ad7c0cd6d1098"
            ]
        ]
    },
    {
        "id": "7aa08ed0106b83c9",
        "type": "debug",
        "z": "6677d7ade5781d37",
        "name": "debug 52",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "statusVal": "",
        "statusType": "auto",
        "x": 280,
        "y": 660,
        "wires": []
    },
    {
        "id": "47b12596f39b9eb8",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    },
    {
        "id": "23910bfd6ab1a872",
        "type": "mqtt-broker",
        "name": "",
        "broker": "192.168.151.1",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": "4",
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willRetain": "false",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": ""
    }
]